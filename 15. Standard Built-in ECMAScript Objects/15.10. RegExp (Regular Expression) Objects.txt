>>>>>CM:GREEN
15.10 RegExp (Regular Expression) Objects
>>>>>CM:GREEN
=========================================

>>>>>CM:GREEN
A RegExp object contains a regular expression and the associated flags.

>>>>>CM:GREEN
NOTE The form and functionality of regular expressions is modelled after the regular expression
>>>>>CM:GREEN
facility in the Perl 5 programming language.

>>>>>CM:GREEN
15.10.1 Patterns
>>>>>CM:GREEN
================

>>>>>CM:GREEN
The RegExp constructor applies the following grammar to the input pattern String. An error occurs if
>>>>>CM:GREEN
the grammar cannot interpret the String as an expansion of Pattern.

>>>>>CM:GREEN
Syntax
>>>>>CM:GREEN
------

>>>>>CM:GREEN
Pattern ::

>>>>>CM:GREEN
Disjunction

>>>>>CM:GREEN
Disjunction ::

>>>>>CM:GREEN
Alternative

>>>>>CM:GREEN
Alternative | Disjunction

>>>>>CM:GREEN
Alternative ::

>>>>>CM:GREEN
[empty]

>>>>>CM:GREEN
Alternative Term

>>>>>CM:GREEN
Term ::

>>>>>CM:GREEN
Assertion

>>>>>CM:GREEN
Atom

>>>>>CM:GREEN
Atom Quantifier

>>>>>CM:GREEN
Assertion ::

>>>>>CM:GREEN
^

>>>>>CM:GREEN
$

>>>>>CM:GREEN
\ b

>>>>>CM:GREEN
\ B

>>>>>CM:GREEN
( ? = Disjunction )

>>>>>CM:GREEN
( ? ! Disjunction )

>>>>>CM:GREEN
Quantifier ::

>>>>>CM:GREEN
QuantifierPrefix

>>>>>CM:GREEN
QuantifierPrefix ?

>>>>>CM:GREEN
QuantifierPrefix ::

>>>>>CM:GREEN
*

>>>>>CM:GREEN
+

>>>>>CM:GREEN
?

>>>>>CM:GREEN
{ DecimalDigits }

>>>>>CM:GREEN
{ DecimalDigits , }

>>>>>CM:GREEN
{ DecimalDigits , DecimalDigits }

>>>>>CM:GREEN
Atom ::

>>>>>CM:GREEN
PatternCharacter

>>>>>CM:GREEN
.

>>>>>CM:GREEN
\ AtomEscape

>>>>>CM:GREEN
CharacterClass

>>>>>CM:GREEN
( Disjunction )

>>>>>CM:GREEN
( ? : Disjunction )

>>>>>CM:GREEN
PatternCharacter ::

>>>>>CM:GREEN
SourceCharacter but not one of

>>>>>CM:GREEN
^ $ \ . * + ? ( ) [ ] { } |

>>>>>CM:GREEN
AtomEscape ::

>>>>>CM:GREEN
DecimalEscape

>>>>>CM:GREEN
CharacterEscape

>>>>>CM:GREEN
CharacterClassEscape

>>>>>CM:GREEN
CharacterEscape ::

>>>>>CM:GREEN
ControlEscape

>>>>>CM:GREEN
c ControlLetter

>>>>>CM:GREEN
HexEscapeSequence

>>>>>CM:GREEN
UnicodeEscapeSequence

>>>>>CM:GREEN
IdentityEscape

>>>>>CM:GREEN
ControlEscape :: one of

>>>>>CM:GREEN
f n r t v

>>>>>CM:GREEN
ControlLetter :: one of

>>>>>CM:GREEN
a b c d e f g h i j k l m n o p q r s t u v w x y z

>>>>>CM:GREEN
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

>>>>>CM:GREEN
IdentityEscape ::

>>>>>CM:GREEN
SourceCharacter but not IdentifierPart

>>>>>CM:GREEN
<ZWJ>

>>>>>CM:GREEN
<ZWNJ>

>>>>>CM:GREEN
DecimalEscape ::

>>>>>CM:GREEN
DecimalIntegerLiteral [lookahead ∉ DecimalDigit]

>>>>>CM:GREEN
CharacterClassEscape :: one of

>>>>>CM:GREEN
d D s S w W

>>>>>CM:GREEN
CharacterClass ::

>>>>>CM:GREEN
[ [lookahead ∉ {^}] ClassRanges ]

>>>>>CM:GREEN
[ ^ ClassRanges ]

>>>>>CM:GREEN
ClassRanges ::

>>>>>CM:GREEN
[empty]

>>>>>CM:GREEN
NonemptyClassRanges

>>>>>CM:GREEN
NonemptyClassRanges ::

>>>>>CM:GREEN
ClassAtom

>>>>>CM:GREEN
ClassAtom NonemptyClassRangesNoDash

>>>>>CM:GREEN
ClassAtom - ClassAtom ClassRanges

>>>>>CM:GREEN
NonemptyClassRangesNoDash ::

>>>>>CM:GREEN
ClassAtom

>>>>>CM:GREEN
ClassAtomNoDash NonemptyClassRangesNoDash

>>>>>CM:GREEN
ClassAtomNoDash - ClassAtom ClassRanges

>>>>>CM:GREEN
ClassAtom ::

>>>>>CM:GREEN
-

>>>>>CM:GREEN
ClassAtomNoDash

>>>>>CM:GREEN
ClassAtomNoDash ::

>>>>>CM:GREEN
SourceCharacter but not one of \ or ] or -

>>>>>CM:GREEN
\ ClassEscape

>>>>>CM:GREEN
ClassEscape ::

>>>>>CM:GREEN
DecimalEscape

>>>>>CM:GREEN
b

>>>>>CM:GREEN
CharacterEscape

>>>>>CM:GREEN
CharacterClassEscape

>>>>>CM:GREEN
15.10.2 Pattern Semantics
>>>>>CM:GREEN
=========================

>>>>>CM:GREEN
A regular expression pattern is converted into an internal procedure using the process described
>>>>>CM:GREEN
below. An implementation is encouraged to use more efficient algorithms than the ones listed below,
>>>>>CM:GREEN
as long as the results are the same. The internal procedure is used as the value of a RegExp
>>>>>CM:GREEN
object’s [[Match]] internal property.

>>>>>CM:GREEN
15.10.2.1 Notation
>>>>>CM:GREEN
==================

>>>>>CM:GREEN
The descriptions below use the following variables:

>>>>>CM:GREEN
-   Input is the String being matched by the regular expression pattern. The notation input[n] means
>>>>>CM:GREEN
    the nth character of input, where n can range between 0 (inclusive) and InputLength (exclusive).

>>>>>CM:GREEN
-   InputLength is the number of characters in the Input String.

>>>>>CM:GREEN
-   NcapturingParens is the total number of left capturing parentheses (i.e. the total number of
>>>>>CM:GREEN
    times the Atom :: ( Disjunction ) production is expanded) in the pattern. A left capturing
>>>>>CM:GREEN
    parenthesis is any ( pattern character that is matched by the ( terminal of the Atom :: (
>>>>>CM:GREEN
    Disjunction ) production.

>>>>>CM:GREEN
-   IgnoreCase is the setting of the RegExp object’s ignoreCase property.

>>>>>CM:GREEN
-   Multiline is the setting of the RegExp object’s multiline property.

>>>>>CM:GREEN
Furthermore, the descriptions below use the following internal data structures:

>>>>>CM:GREEN
-   A CharSet is a mathematical set of characters.

>>>>>CM:GREEN
-   A State is an ordered pair (endIndex, captures) where endIndex is an integer and captures is an
>>>>>CM:GREEN
    internal array of NcapturingParens values. States are used to represent partial match states in
>>>>>CM:GREEN
    the regular expression matching algorithms. The endIndex is one plus the index of the last input
>>>>>CM:GREEN
    character matched so far by the pattern, while captures holds the results of capturing
>>>>>CM:GREEN
    parentheses. The nth element of captures is either a String that represents the value obtained
>>>>>CM:GREEN
    by the nth set of capturing parentheses or undefined if the nth set of capturing parentheses
>>>>>CM:GREEN
    hasn’t been reached yet. Due to backtracking, many States may be in use at any time during the
>>>>>CM:GREEN
    matching process.

>>>>>CM:GREEN
-   A MatchResult is either a State or the special token failure that indicates that the match
>>>>>CM:GREEN
    failed.

>>>>>CM:GREEN
-   A Continuation procedure is an internal closure (i.e. an internal procedure with some arguments
>>>>>CM:GREEN
    already bound to values) that takes one State argument and returns a MatchResult result. If an
>>>>>CM:GREEN
    internal closure references variables bound in the function that creates the closure, the
>>>>>CM:GREEN
    closure uses the values that these variables had at the time the closure was created. The
>>>>>CM:GREEN
    Continuation attempts to match the remaining portion (specified by the closure’s already-bound
>>>>>CM:GREEN
    arguments) of the pattern against the input String, starting at the intermediate state given by
>>>>>CM:GREEN
    its State argument. If the match succeeds, the Continuation returns the final State that it
>>>>>CM:GREEN
    reached; if the match fails, the Continuation returns failure.

>>>>>CM:GREEN
-   A Matcher procedure is an internal closure that takes two arguments – a State and a Continuation
>>>>>CM:GREEN
    – and returns a MatchResult result. A Matcher attempts to match a middle subpattern (specified
>>>>>CM:GREEN
    by the closure’s already-bound arguments) of the pattern against the input String, starting at
>>>>>CM:GREEN
    the intermediate state given by its State argument. The Continuation argument should be a
>>>>>CM:GREEN
    closure that matches the rest of the pattern. After matching the subpattern of a pattern to
>>>>>CM:GREEN
    obtain a new State, the Matcher then calls Continuation on that new State to test if the rest of
>>>>>CM:GREEN
    the pattern can match as well. If it can, the Matcher returns the State returned by
>>>>>CM:GREEN
    Continuation; if not, the Matcher may try different choices at its choice points, repeatedly
>>>>>CM:GREEN
    calling Continuation until it either succeeds or all possibilities have been exhausted.

>>>>>CM:GREEN
-   An AssertionTester procedure is an internal closure that takes a State argument and returns a
>>>>>CM:GREEN
    Boolean result. The assertion tester tests a specific condition (specified by the closure’s
>>>>>CM:GREEN
    already-bound arguments) against the current place in the input String and returns true if the
>>>>>CM:GREEN
    condition matched or false if not.

>>>>>CM:GREEN
-   An EscapeValue is either a character or an integer. An EscapeValue is used to denote the
>>>>>CM:GREEN
    interpretation of a DecimalEscape escape sequence: a character ch means that the escape sequence
>>>>>CM:GREEN
    is interpreted as the character ch, while an integer n means that the escape sequence is
>>>>>CM:GREEN
    interpreted as a backreference to the nth set of capturing parentheses.

>>>>>CM:GREEN
15.10.2.2 Pattern
>>>>>CM:GREEN
=================

>>>>>CM:GREEN
The production Pattern :: Disjunction evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Disjunction to obtain a Matcher m.
>>>>>CM:GREEN
2.  Return an internal closure that takes two arguments, a String str and an integer index, and
>>>>>CM:GREEN
    performs the following:
>>>>>CM:GREEN
    1.  Let Input be the given String str. This variable will be used throughout the algorithms in
>>>>>CM:GREEN
        15.10.2.
>>>>>CM:GREEN
    2.  Let InputLength be the length of Input. This variable will be used throughout the algorithms
>>>>>CM:GREEN
        in 15.10.2.
>>>>>CM:GREEN
    3.  Let c be a Continuation that always returns its State argument as a successful MatchResult.
>>>>>CM:GREEN
    4.  Let cap be an internal array of NcapturingParens undefined values, indexed 1 through
>>>>>CM:GREEN
        NcapturingParens.
>>>>>CM:GREEN
    5.  Let x be the State (index, cap).
>>>>>CM:GREEN
    6.  Call m(x, c) and return its result.

>>>>>CM:GREEN
NOTE A Pattern evaluates (“compiles”) to an internal procedure value. RegExp.prototype.exec can then
>>>>>CM:GREEN
apply this procedure to a String and an offset within the String to determine whether the pattern
>>>>>CM:GREEN
would match starting at exactly that offset within the String, and, if it does match, what the
>>>>>CM:GREEN
values of the capturing parentheses would be. The algorithms in 15.10.2 are designed so that
>>>>>CM:GREEN
compiling a pattern may throw a SyntaxError exception; on the other hand, once the pattern is
>>>>>CM:GREEN
successfully compiled, applying its result internal procedure to find a match in a String cannot
>>>>>CM:GREEN
throw an exception (except for any host-defined exceptions that can occur anywhere such as
>>>>>CM:GREEN
out-of-memory).

>>>>>CM:GREEN
15.10.2.3 Disjunction
>>>>>CM:GREEN
=====================

>>>>>CM:GREEN
The production Disjunction :: Alternative evaluates by evaluating Alternative to obtain a Matcher
>>>>>CM:GREEN
and returning that Matcher.

>>>>>CM:GREEN
The production Disjunction :: Alternative | Disjunction evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Alternative to obtain a Matcher m1.
>>>>>CM:GREEN
2.  Evaluate Disjunction to obtain a Matcher m2.
>>>>>CM:GREEN
3.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following:
>>>>>CM:GREEN
    1.  Call m1(x, c) and let r be its result.
>>>>>CM:GREEN
    2.  If r isn’t failure, return r.
>>>>>CM:GREEN
    3.  Call m2(x, c) and return its result.

>>>>>CM:GREEN
NOTE The | regular expression operator separates two alternatives. The pattern first tries to match
>>>>>CM:GREEN
the left Alternative (followed by the sequel of the regular expression); if it fails, it tries to
>>>>>CM:GREEN
match the right Disjunction (followed by the sequel of the regular expression). If the left
>>>>>CM:GREEN
Alternative, the right Disjunction, and the sequel all have choice points, all choices in the sequel
>>>>>CM:GREEN
are tried before moving on to the next choice in the left Alternative. If choices in the left
>>>>>CM:GREEN
Alternative are exhausted, the right Disjunction is tried instead of the left Alternative. Any
>>>>>CM:GREEN
capturing parentheses inside a portion of the pattern skipped by | produce undefined values instead
>>>>>CM:GREEN
of Strings. Thus, for example,

>>>>>CM:GREEN
    /a|ab/.exec("abc")

>>>>>CM:GREEN
returns the result "a" and not "ab". Moreover,

>>>>>CM:GREEN
    /((a)|(ab))((c)|(bc))/.exec("abc")

>>>>>CM:GREEN
returns the array

>>>>>CM:GREEN
    ["abc", "a", "a", undefined, "bc", undefined, "bc"]

>>>>>CM:GREEN
and not

>>>>>CM:GREEN
    ["abc", "ab", undefined, "ab", "c", "c", undefined]

>>>>>CM:GREEN
15.10.2.4 Alternative
>>>>>CM:GREEN
=====================

>>>>>CM:GREEN
The production Alternative :: [empty] evaluates by returning a Matcher that takes two arguments, a
>>>>>CM:GREEN
State x and a Continuation c, and returns the result of calling c(x).

>>>>>CM:GREEN
The production Alternative :: Alternative Term evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Alternative to obtain a Matcher m1.
>>>>>CM:GREEN
2.  Evaluate Term to obtain a Matcher m2.
>>>>>CM:GREEN
3.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following:
>>>>>CM:GREEN
    1.  Create a Continuation d that takes a State argument y and returns the result of calling
>>>>>CM:GREEN
        m2(y, c).
>>>>>CM:GREEN
    2.  Call m1(x, d) and return its result.

>>>>>CM:GREEN
NOTE Consecutive Terms try to simultaneously match consecutive portions of the input String. If the
>>>>>CM:GREEN
left Alternative, the right Term, and the sequel of the regular expression all have choice points,
>>>>>CM:GREEN
all choices in the sequel are tried before moving on to the next choice in the right Term, and all
>>>>>CM:GREEN
choices in the right Term are tried before moving on to the next choice in the left Alternative.

>>>>>CM:GREEN
15.10.2.5 Term
>>>>>CM:GREEN
==============

>>>>>CM:GREEN
The production Term :: Assertion evaluates by returning an internal Matcher closure that takes two
>>>>>CM:GREEN
arguments, a State x and a Continuation c, and performs the following:

>>>>>CM:GREEN
1.  Evaluate Assertion to obtain an AssertionTester t.
>>>>>CM:GREEN
2.  Call t(x) and let r be the resulting Boolean value.
>>>>>CM:GREEN
3.  If r is false, return failure.
>>>>>CM:GREEN
4.  Call c(x) and return its result.

>>>>>CM:GREEN
The production Term :: Atom evaluates by evaluating Atom to obtain a Matcher and returning that
>>>>>CM:GREEN
Matcher.

>>>>>CM:GREEN
The production Term :: Atom Quantifier evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Atom to obtain a Matcher m.
>>>>>CM:GREEN
2.  Evaluate Quantifier to obtain the three results: an integer min, an integer (or ∞) max, and
>>>>>CM:GREEN
    Boolean greedy.
>>>>>CM:GREEN
3.  If max is finite and less than min, then throw a SyntaxError exception.
>>>>>CM:GREEN
4.  Let parenIndex be the number of left capturing parentheses in the entire regular expression that
>>>>>CM:GREEN
    occur to the left of this production expansion’s Term. This is the total number of times the
>>>>>CM:GREEN
    Atom :: ( Disjunction ) production is expanded prior to this production’s Term plus the total
>>>>>CM:GREEN
    number of Atom :: ( Disjunction ) productions enclosing this Term.
>>>>>CM:GREEN
5.  Let parenCount be the number of left capturing parentheses in the expansion of this production’s
>>>>>CM:GREEN
    Atom. This is the total number of Atom :: ( Disjunction ) productions enclosed by this
>>>>>CM:GREEN
    production’s Atom.
>>>>>CM:GREEN
6.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following:
>>>>>CM:GREEN
    1.  Call RepeatMatcher(m, min, max, greedy, x, c, parenIndex, parenCount) and return its result.

>>>>>CM:GREEN
The abstract operation RepeatMatcher takes eight parameters, a Matcher m, an integer min, an integer
>>>>>CM:GREEN
(or ∞) max, a Boolean greedy, a State x, a Continuation c, an integer parenIndex, and an integer
>>>>>CM:GREEN
parenCount, and performs the following:

>>>>>CM:GREEN
1.  If max is zero, then call c(x) and return its result.
>>>>>CM:GREEN
2.  Create an internal Continuation closure d that takes one State argument y and performs the
>>>>>CM:GREEN
    following:
>>>>>CM:GREEN
    1.  If min is zero and y’s endIndex is equal to x’s endIndex, then return failure.
>>>>>CM:GREEN
    2.  If min is zero then let min2 be zero; otherwise let min2 be min–1.
>>>>>CM:GREEN
    3.  If max is ∞, then let max2 be ∞; otherwise let max2 be max–1.
>>>>>CM:GREEN
    4.  Call RepeatMatcher(m, min2, max2, greedy, y, c, parenIndex, parenCount) and return its
>>>>>CM:GREEN
        result.

>>>>>CM:GREEN
3.  Let cap be a fresh copy of x’s captures internal array.
>>>>>CM:GREEN
4.  For every integer k that satisfies parenIndex < k and k ≤ parenIndex+parenCount, set cap[k] to
>>>>>CM:GREEN
    undefined.
>>>>>CM:GREEN
5.  Let e be x’s endIndex.
>>>>>CM:GREEN
6.  Let xr be the State (e, cap).
>>>>>CM:GREEN
7.  If min is not zero, then call m(xr, d) and return its result.
>>>>>CM:GREEN
8.  If greedy is false, then
>>>>>CM:GREEN
    1.  Call c(x) and let z be its result.
>>>>>CM:GREEN
    2.  If z is not failure, return z.
>>>>>CM:GREEN
    3.  Call m(xr, d) and return its result.

>>>>>CM:GREEN
9.  Call m(xr, d) and let z be its result.
>>>>>CM:GREEN
10. If z is not failure, return z.
>>>>>CM:GREEN
11. Call c(x) and return its result.

>>>>>CM:GREEN
NOTE 1 An Atom followed by a Quantifier is repeated the number of times specified by the Quantifier.
>>>>>CM:GREEN
A Quantifier can be non-greedy, in which case the Atom pattern is repeated as few times as possible
>>>>>CM:GREEN
while still matching the sequel, or it can be greedy, in which case the Atom pattern is repeated as
>>>>>CM:GREEN
many times as possible while still matching the sequel. The Atom pattern is repeated rather than the
>>>>>CM:GREEN
input String that it matches, so different repetitions of the Atom can match different input
>>>>>CM:GREEN
substrings.

>>>>>CM:GREEN
NOTE 2 If the Atom and the sequel of the regular expression all have choice points, the Atom is
>>>>>CM:GREEN
first matched as many (or as few, if non-greedy) times as possible. All choices in the sequel are
>>>>>CM:GREEN
tried before moving on to the next choice in the last repetition of Atom. All choices in the last
>>>>>CM:GREEN
(nth) repetition of Atom are tried before moving on to the next choice in the next-to-last (n–1)st
>>>>>CM:GREEN
repetition of Atom; at which point it may turn out that more or fewer repetitions of Atom are now
>>>>>CM:GREEN
possible; these are exhausted (again, starting with either as few or as many as possible) before
>>>>>CM:GREEN
moving on to the next choice in the (n-1)st repetition of Atom and so on.

>>>>>CM:GREEN
Compare

>>>>>CM:GREEN
    /a[a-z]{2,4}/.exec("abcdefghi")

>>>>>CM:GREEN
which returns "abcde" with

>>>>>CM:GREEN
    /a[a-z]{2,4}?/.exec("abcdefghi")

>>>>>CM:GREEN
which returns "abc".

>>>>>CM:GREEN
Consider also

>>>>>CM:GREEN
    /(aa|aabaac|ba|b|c)*/.exec("aabaac")

>>>>>CM:GREEN
which, by the choice point ordering above, returns the array

>>>>>CM:GREEN
    ["aaba", "ba"]

>>>>>CM:GREEN
and not any of:

>>>>>CM:GREEN
    ["aabaac", "aabaac"]

>>>>>CM:GREEN
    ["aabaac", "c"]

>>>>>CM:GREEN
The above ordering of choice points can be used to write a regular expression that calculates the
>>>>>CM:GREEN
greatest common divisor of two numbers (represented in unary notation). The following example
>>>>>CM:GREEN
calculates the gcd of 10 and 15:

>>>>>CM:GREEN
    "aaaaaaaaaa,aaaaaaaaaaaaaaa".replace(/^(a+)\1*,\1+$/,"$1")

>>>>>CM:GREEN
which returns the gcd in unary notation "aaaaa".

>>>>>CM:GREEN
NOTE 3 Step 4 of the RepeatMatcher clears Atom’s captures each time Atom is repeated. We can see its
>>>>>CM:GREEN
behaviour in the regular expression

>>>>>CM:GREEN
    /(z)((a+)?(b+)?(c))*/.exec("zaacbbbcac")

>>>>>CM:GREEN
which returns the array

>>>>>CM:GREEN
    ["zaacbbbcac", "z", "ac", "a", undefined, "c"]

>>>>>CM:GREEN
and not

>>>>>CM:GREEN
    ["zaacbbbcac", "z", "ac", "a", "bbb", "c"]

>>>>>CM:GREEN
because each iteration of the outermost * clears all captured Strings contained in the quantified
>>>>>CM:GREEN
Atom, which in this case includes capture Strings numbered 2, 3, 4, and 5.

>>>>>CM:GREEN
NOTE 4 Step 1 of the RepeatMatcher’s d closure states that, once the minimum number of repetitions
>>>>>CM:GREEN
has been satisfied, any more expansions of Atom that match the empty String are not considered for
>>>>>CM:GREEN
further repetitions. This prevents the regular expression engine from falling into an infinite loop
>>>>>CM:GREEN
on patterns such as:

>>>>>CM:GREEN
    /(a*)*/.exec("b")

>>>>>CM:GREEN
or the slightly more complicated:

>>>>>CM:GREEN
    /(a*)b\1+/.exec("baaaac")

>>>>>CM:GREEN
which returns the array

>>>>>CM:GREEN
    ["b", ""]

>>>>>CM:GREEN
15.10.2.6 Assertion
>>>>>CM:GREEN
===================

>>>>>CM:GREEN
The production Assertion :: ^ evaluates by returning an internal AssertionTester closure that takes
>>>>>CM:GREEN
a State argument x and performs the following:

>>>>>CM:GREEN
1.  Let e be x’s endIndex.
>>>>>CM:GREEN
2.  If e is zero, return true.
>>>>>CM:GREEN
3.  If Multiline is false, return false.
>>>>>CM:GREEN
4.  If the character Input[e–1] is one of LineTerminator, return true.
>>>>>CM:GREEN
5.  Return false.

>>>>>CM:GREEN
The production Assertion :: $ evaluates by returning an internal AssertionTester closure that takes
>>>>>CM:GREEN
a State argument x and performs the following:

>>>>>CM:GREEN
1.  Let e be x’s endIndex.
>>>>>CM:GREEN
2.  If e is equal to InputLength, return true.
>>>>>CM:GREEN
3.  If multiline is false, return false.
>>>>>CM:GREEN
4.  If the character Input[e] is one of LineTerminator, return true.
>>>>>CM:GREEN
5.  Return false.

>>>>>CM:GREEN
The production Assertion :: \ b evaluates by returning an internal AssertionTester closure that
>>>>>CM:GREEN
takes a State argument x and performs the following:

>>>>>CM:GREEN
1.  Let e be x’s endIndex.
>>>>>CM:GREEN
2.  Call IsWordChar(e–1) and let a be the Boolean result.
>>>>>CM:GREEN
3.  Call IsWordChar(e) and let b be the Boolean result.
>>>>>CM:GREEN
4.  If a is true and b is false, return true.
>>>>>CM:GREEN
5.  If a is false and b is true, return true.
>>>>>CM:GREEN
6.  Return false.

>>>>>CM:GREEN
The production Assertion :: \ B evaluates by returning an internal AssertionTester closure that
>>>>>CM:GREEN
takes a State argument x and performs the following:

>>>>>CM:GREEN
1.  Let e be x’s endIndex.
>>>>>CM:GREEN
2.  Call IsWordChar(e–1) and let a be the Boolean result.
>>>>>CM:GREEN
3.  Call IsWordChar(e) and let b be the Boolean result.
>>>>>CM:GREEN
4.  If a is true and b is false, return false.
>>>>>CM:GREEN
5.  If a is false and b is true, return false.
>>>>>CM:GREEN
6.  Return true.

>>>>>CM:GREEN
The production Assertion :: ( ? = Disjunction ) evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Disjunction to obtain a Matcher m.
>>>>>CM:GREEN
2.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following steps:
>>>>>CM:GREEN
    1.  Let d be a Continuation that always returns its State argument as a successful MatchResult.
>>>>>CM:GREEN
    2.  Call m(x, d) and let r be its result.
>>>>>CM:GREEN
    3.  If r is failure, return failure.
>>>>>CM:GREEN
    4.  Let y be r’s State.
>>>>>CM:GREEN
    5.  Let cap be y’s captures internal array.
>>>>>CM:GREEN
    6.  Let xe be x’s endIndex.
>>>>>CM:GREEN
    7.  Let z be the State (xe, cap).
>>>>>CM:GREEN
    8.  Call c(z) and return its result.

>>>>>CM:GREEN
The production Assertion :: ( ? ! Disjunction ) evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Disjunction to obtain a Matcher m.
>>>>>CM:GREEN
2.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following steps:
>>>>>CM:GREEN
    1.  Let d be a Continuation that always returns its State argument as a successful MatchResult.
>>>>>CM:GREEN
    2.  Call m(x, d) and let r be its result.
>>>>>CM:GREEN
    3.  If r isn’t failure, return failure.
>>>>>CM:GREEN
    4.  Call c(x) and return its result.

>>>>>CM:GREEN
The abstract operation IsWordChar takes an integer parameter e and performs the following:

>>>>>CM:GREEN
1.  If e == –1 or e == InputLength, return false.
>>>>>CM:GREEN
2.  Let c be the character Input[e].
>>>>>CM:GREEN
3.  If c is one of the sixty-three characters below, return true.

>>>>>CM:GREEN
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
>>>>>CM:GREEN
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
>>>>>CM:GREEN
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
>>>>>CM:GREEN
  0   1   2   3   4   5   6   7   8   9   _                                                           
>>>>>CM:GREEN
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

>>>>>CM:GREEN
1.  Return false.

>>>>>CM:GREEN
15.10.2.7 Quantifier
>>>>>CM:GREEN
====================

>>>>>CM:GREEN
The production Quantifier :: QuantifierPrefix evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.
>>>>>CM:GREEN
2.  Return the three results min, max, and true.

>>>>>CM:GREEN
The production Quantifier :: QuantifierPrefix ? evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate QuantifierPrefix to obtain the two results: an integer min and an integer (or ∞) max.
>>>>>CM:GREEN
2.  Return the three results min, max, and false.

>>>>>CM:GREEN
The production QuantifierPrefix :: * evaluates by returning the two results 0 and ∞.

>>>>>CM:GREEN
The production QuantifierPrefix :: + evaluates by returning the two results 1 and ∞.

>>>>>CM:GREEN
The production QuantifierPrefix :: ? evaluates by returning the two results 0 and 1.

>>>>>CM:GREEN
The production QuantifierPrefix :: { DecimalDigits } evaluates as follows:

>>>>>CM:GREEN
1.  Let i be the MV of DecimalDigits (see 7.8.3).
>>>>>CM:GREEN
2.  Return the two results i and i.

>>>>>CM:GREEN
The production QuantifierPrefix :: { DecimalDigits , } evaluates as follows:

>>>>>CM:GREEN
1.  Let i be the MV of DecimalDigits.
>>>>>CM:GREEN
2.  Return the two results i and ∞.

>>>>>CM:GREEN
The production QuantifierPrefix :: { DecimalDigits , DecimalDigits } evaluates as follows:

>>>>>CM:GREEN
1.  Let i be the MV of the first DecimalDigits.
>>>>>CM:GREEN
2.  Let j be the MV of the second DecimalDigits.
>>>>>CM:GREEN
3.  Return the two results i and j.

>>>>>CM:GREEN
15.10.2.8 Atom
>>>>>CM:GREEN
==============

>>>>>CM:GREEN
The production Atom :: PatternCharacter evaluates as follows:

>>>>>CM:GREEN
1.  Let ch be the character represented by PatternCharacter.
>>>>>CM:GREEN
2.  Let A be a one-element CharSet containing the character ch.
>>>>>CM:GREEN
3.  Call CharacterSetMatcher(A, false) and return its Matcher result.

>>>>>CM:GREEN
The production Atom :: . evaluates as follows:

>>>>>CM:GREEN
1.  Let A be the set of all characters except LineTerminator.
>>>>>CM:GREEN
2.  Call CharacterSetMatcher(A, false) and return its Matcher result.

>>>>>CM:GREEN
The production Atom :: \ AtomEscape evaluates by evaluating AtomEscape to obtain a Matcher and
>>>>>CM:GREEN
returning that Matcher.

>>>>>CM:GREEN
The production Atom :: CharacterClass evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate CharacterClass to obtain a CharSet A and a Boolean invert.
>>>>>CM:GREEN
2.  Call CharacterSetMatcher(A, invert) and return its Matcher result.

>>>>>CM:GREEN
The production Atom :: ( Disjunction ) evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate Disjunction to obtain a Matcher m.
>>>>>CM:GREEN
2.  Let parenIndex be the number of left capturing parentheses in the entire regular expression that
>>>>>CM:GREEN
    occur to the left of this production expansion’s initial left parenthesis. This is the total
>>>>>CM:GREEN
    number of times the Atom :: ( Disjunction ) production is expanded prior to this production’s
>>>>>CM:GREEN
    Atom plus the total number of Atom :: ( Disjunction ) productions enclosing this Atom.
>>>>>CM:GREEN
3.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following steps:
>>>>>CM:GREEN
    1.  Create an internal Continuation closure d that takes one State argument y and performs the
>>>>>CM:GREEN
        following steps:
>>>>>CM:GREEN
        1.  Let cap be a fresh copy of y’s captures internal array.
>>>>>CM:GREEN
        2.  Let xe be x’s endIndex.
>>>>>CM:GREEN
        3.  Let ye be y’s endIndex.
>>>>>CM:GREEN
        4.  Let s be a fresh String whose characters are the characters of Input at positions xe
>>>>>CM:GREEN
            (inclusive) through ye (exclusive).
>>>>>CM:GREEN
        5.  Set cap[parenIndex+1] to s.
>>>>>CM:GREEN
        6.  Let z be the State (ye, cap).
>>>>>CM:GREEN
        7.  Call c(z) and return its result.

>>>>>CM:GREEN
    2.  Call m(x, d) and return its result.

>>>>>CM:GREEN
The production Atom :: ( ? : Disjunction ) evaluates by evaluating Disjunction to obtain a Matcher
>>>>>CM:GREEN
and returning that Matcher.

>>>>>CM:GREEN
The abstract operation CharacterSetMatcher takes two arguments, a CharSet A and a Boolean flag
>>>>>CM:GREEN
invert, and performs the following:

>>>>>CM:GREEN
1.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following steps:
>>>>>CM:GREEN
    1.  Let e be x’s endIndex.
>>>>>CM:GREEN
    2.  If e == InputLength, return failure.
>>>>>CM:GREEN
    3.  Let ch be the character Input[e].
>>>>>CM:GREEN
    4.  Let cc be the result of Canonicalize(ch).
>>>>>CM:GREEN
    5.  If invert is false, then
>>>>>CM:GREEN
        1.  If there does not exist a member a of set A such that Canonicalize(a) == cc, return
>>>>>CM:GREEN
            failure.

>>>>>CM:GREEN
    6.  Else invert is true,
>>>>>CM:GREEN
        1.  If there exists a member a of set A such that Canonicalize(a) == cc, return failure.

>>>>>CM:GREEN
    7.  Let cap be x’s captures internal array.
>>>>>CM:GREEN
    8.  Let y be the State (e+1, cap).
>>>>>CM:GREEN
    9.  Call c(y) and return its result.

>>>>>CM:GREEN
The abstract operation Canonicalize takes a character parameter ch and performs the following steps:

>>>>>CM:GREEN
1.  If IgnoreCase is false, return ch.
>>>>>CM:GREEN
2.  Let u be ch converted to upper case as if by calling the standard built-in method
>>>>>CM:GREEN
    String.prototype.toUpperCase on the one-character String ch.
>>>>>CM:GREEN
3.  If u does not consist of a single character, return ch.
>>>>>CM:GREEN
4.  Let cu be u’s character.
>>>>>CM:GREEN
5.  If ch’s code unit value is greater than or equal to decimal 128 and cu’s code unit value is less
>>>>>CM:GREEN
    than decimal 128, then return ch.
>>>>>CM:GREEN
6.  Return cu.

>>>>>CM:GREEN
NOTE 1 Parentheses of the form ( Disjunction ) serve both to group the components of the Disjunction
>>>>>CM:GREEN
pattern together and to save the result of the match. The result can be used either in a
>>>>>CM:GREEN
backreference (\ followed by a nonzero decimal number), referenced in a replace String, or returned
>>>>>CM:GREEN
as part of an array from the regular expression matching internal procedure. To inhibit the
>>>>>CM:GREEN
capturing behaviour of parentheses, use the form (?: Disjunction ) instead.

>>>>>CM:GREEN
NOTE 2 The form (?= Disjunction ) specifies a zero-width positive lookahead. In order for it to
>>>>>CM:GREEN
succeed, the pattern inside Disjunction must match at the current position, but the current position
>>>>>CM:GREEN
is not advanced before matching the sequel. If Disjunction can match at the current position in
>>>>>CM:GREEN
several ways, only the first one is tried. Unlike other regular expression operators, there is no
>>>>>CM:GREEN
backtracking into a (?= form (this unusual behaviour is inherited from Perl). This only matters when
>>>>>CM:GREEN
the Disjunction contains capturing parentheses and the sequel of the pattern contains backreferences
>>>>>CM:GREEN
to those captures.

>>>>>CM:GREEN
For example,

>>>>>CM:GREEN
    /(?=(a+))/.exec("baaabac")

>>>>>CM:GREEN
matches the empty String immediately after the first b and therefore returns the array:

>>>>>CM:GREEN
    ["", "aaa"]

>>>>>CM:GREEN
To illustrate the lack of backtracking into the lookahead, consider:

>>>>>CM:GREEN
    /(?=(a+))a*b\1/.exec("baaabac")

>>>>>CM:GREEN
This expression returns

>>>>>CM:GREEN
    ["aba", "a"]

>>>>>CM:GREEN
and not:

>>>>>CM:GREEN
    ["aaaba", "a"]

>>>>>CM:GREEN
NOTE 3 The form (?! Disjunction ) specifies a zero-width negative lookahead. In order for it to
>>>>>CM:GREEN
succeed, the pattern inside Disjunction must fail to match at the current position. The current
>>>>>CM:GREEN
position is not advanced before matching the sequel. Disjunction can contain capturing parentheses,
>>>>>CM:GREEN
but backreferences to them only make sense from within Disjunction itself. Backreferences to these
>>>>>CM:GREEN
capturing parentheses from elsewhere in the pattern always return undefined because the negative
>>>>>CM:GREEN
lookahead must fail for the pattern to succeed. For example,

>>>>>CM:GREEN
    /(.*?)a(?!(a+)b\2c)\2(.*)/.exec("baaabaac")

>>>>>CM:GREEN
looks for an a not immediately followed by some positive number n of a’s, a b, another n a’s
>>>>>CM:GREEN
(specified by the first \2) and a c. The second \2 is outside the negative lookahead, so it matches
>>>>>CM:GREEN
against undefined and therefore always succeeds. The whole expression returns the array:

>>>>>CM:GREEN
    ["baaabaac", "ba", undefined, "abaac"]

>>>>>CM:GREEN
In case-insignificant matches all characters are implicitly converted to upper case immediately
>>>>>CM:GREEN
before they are compared. However, if converting a character to upper case would expand that
>>>>>CM:GREEN
character into more than one character (such as converting "ß" (\u00DF) into "SS"), then the
>>>>>CM:GREEN
character is left as-is instead. The character is also left as-is if it is not an ASCII character
>>>>>CM:GREEN
but converting it to upper case would make it into an ASCII character. This prevents Unicode
>>>>>CM:GREEN
characters such as \u0131 and \u017F from matching regular expressions such as /[a‑z]/i, which are
>>>>>CM:GREEN
only intended to match ASCII letters. Furthermore, if these conversions were allowed, then /[^\W]/i
>>>>>CM:GREEN
would match each of a, b, …, h, but not i or s.

>>>>>CM:GREEN
15.10.2.9 AtomEscape
>>>>>CM:GREEN
====================

>>>>>CM:GREEN
The production AtomEscape :: DecimalEscape evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate DecimalEscape to obtain an EscapeValue E.
>>>>>CM:GREEN
2.  If E is a character, then
>>>>>CM:GREEN
    1.  Let ch be E’s character.
>>>>>CM:GREEN
    2.  Let A be a one-element CharSet containing the character ch.
>>>>>CM:GREEN
    3.  Call CharacterSetMatcher(A, false) and return its Matcher result.

>>>>>CM:GREEN
3.  E must be an integer. Let n be that integer.
>>>>>CM:GREEN
4.  If n=0 or n>NCapturingParens then throw a SyntaxError exception.
>>>>>CM:GREEN
5.  Return an internal Matcher closure that takes two arguments, a State x and a Continuation c, and
>>>>>CM:GREEN
    performs the following:
>>>>>CM:GREEN
    1.  Let cap be x’s captures internal array.
>>>>>CM:GREEN
    2.  Let s be cap[n].
>>>>>CM:GREEN
    3.  If s is undefined, then call c(x) and return its result.
>>>>>CM:GREEN
    4.  Let e be x’s endIndex.
>>>>>CM:GREEN
    5.  Let len be s’s length.
>>>>>CM:GREEN
    6.  Let f be e+len.
>>>>>CM:GREEN
    7.  If f>InputLength, return failure.
>>>>>CM:GREEN
    8.  If there exists an integer i between 0 (inclusive) and len (exclusive) such that
>>>>>CM:GREEN
        Canonicalize(s[i]) is not the same character as Canonicalize(Input [e+i]), then return
>>>>>CM:GREEN
        failure.
>>>>>CM:GREEN
    9.  Let y be the State (f, cap).
>>>>>CM:GREEN
    10. Call c(y) and return its result.

>>>>>CM:GREEN
The production AtomEscape :: CharacterEscape evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate CharacterEscape to obtain a character ch.
>>>>>CM:GREEN
2.  Let A be a one-element CharSet containing the character ch.
>>>>>CM:GREEN
3.  Call CharacterSetMatcher(A, false) and return its Matcher result.

>>>>>CM:GREEN
The production AtomEscape :: CharacterClassEscape evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate CharacterClassEscape to obtain a CharSet A.
>>>>>CM:GREEN
2.  Call CharacterSetMatcher(A, false) and return its Matcher result.

>>>>>CM:GREEN
NOTE An escape sequence of the form \ followed by a nonzero decimal number n matches the result of
>>>>>CM:GREEN
the nth set of capturing parentheses (see 15.10.2.11). It is an error if the regular expression has
>>>>>CM:GREEN
fewer than n capturing parentheses. If the regular expression has n or more capturing parentheses
>>>>>CM:GREEN
but the nth one is undefined because it has not captured anything, then the backreference always
>>>>>CM:GREEN
succeeds.

>>>>>CM:GREEN
15.10.2.10 CharacterEscape
>>>>>CM:GREEN
==========================

>>>>>CM:GREEN
The production CharacterEscape :: ControlEscape evaluates by returning the character according to
>>>>>CM:GREEN
Table 23.

>>>>>CM:GREEN
Table 23 — ControlEscape Character Values

>>>>>CM:GREEN
  ControlEscape   Code Unit   Name                   Symbol
>>>>>CM:GREEN
  --------------- ----------- ---------------------- --------
>>>>>CM:GREEN
  t               \u0009      horizontal tab         <HT>
>>>>>CM:GREEN
  n               \u000A      line feed (new line)   <LF>
>>>>>CM:GREEN
  v               \u000B      vertical tab           <VT>
>>>>>CM:GREEN
  f               \u000C      form feed              <FF>
>>>>>CM:GREEN
  r               \u000D      carriage return        <CR>

>>>>>CM:GREEN
The production CharacterEscape :: c ControlLetter evaluates as follows:

>>>>>CM:GREEN
1.  Let ch be the character represented by ControlLetter.
>>>>>CM:GREEN
2.  Let i be ch’s code unit value.
>>>>>CM:GREEN
3.  Let j be the remainder of dividing i by 32.
>>>>>CM:GREEN
4.  Return the character whose code unit value is j.

>>>>>CM:GREEN
The production CharacterEscape :: HexEscapeSequence evaluates by evaluating the CV of the
>>>>>CM:GREEN
HexEscapeSequence (see 7.8.4) and returning its character result.

>>>>>CM:GREEN
The production CharacterEscape :: UnicodeEscapeSequence evaluates by evaluating the CV of the
>>>>>CM:GREEN
UnicodeEscapeSequence (see 7.8.4) and returning its character result.

>>>>>CM:GREEN
The production CharacterEscape :: IdentityEscape evaluates by returning the character represented by
>>>>>CM:GREEN
IdentityEscape.

>>>>>CM:GREEN
15.10.2.11 DecimalEscape
>>>>>CM:GREEN
========================

>>>>>CM:GREEN
The production DecimalEscape :: DecimalIntegerLiteral [lookahead ∉ DecimalDigit] evaluates as
>>>>>CM:GREEN
follows:

>>>>>CM:GREEN
1.  Let i be the MV of DecimalIntegerLiteral.
>>>>>CM:GREEN
2.  If i is zero, return the EscapeValue consisting of a <NUL> character (Unicode value 0000).
>>>>>CM:GREEN
3.  Return the EscapeValue consisting of the integer i.

>>>>>CM:GREEN
The definition of “the MV of DecimalIntegerLiteral” is in 7.8.3.

>>>>>CM:GREEN
NOTE If \ is followed by a decimal number n whose first digit is not 0, then the escape sequence is
>>>>>CM:GREEN
considered to be a backreference. It is an error if n is greater than the total number of left
>>>>>CM:GREEN
capturing parentheses in the entire regular expression. \0 represents the <NUL> character and cannot
>>>>>CM:GREEN
be followed by a decimal digit.

>>>>>CM:GREEN
15.10.2.12 CharacterClassEscape
>>>>>CM:GREEN
===============================

>>>>>CM:GREEN
The production CharacterClassEscape :: d evaluates by returning the ten-element set of characters
>>>>>CM:GREEN
containing the characters 0 through 9 inclusive.

>>>>>CM:GREEN
The production CharacterClassEscape :: D evaluates by returning the set of all characters not
>>>>>CM:GREEN
included in the set returned by CharacterClassEscape :: d .

>>>>>CM:GREEN
The production CharacterClassEscape :: s evaluates by returning the set of characters containing the
>>>>>CM:GREEN
characters that are on the right-hand side of the WhiteSpace (7.2) or LineTerminator (7.3)
>>>>>CM:GREEN
productions.

>>>>>CM:GREEN
The production CharacterClassEscape :: S evaluates by returning the set of all characters not
>>>>>CM:GREEN
included in the set returned by CharacterClassEscape :: s .

>>>>>CM:GREEN
The production CharacterClassEscape :: w evaluates by returning the set of characters containing the
>>>>>CM:GREEN
sixty-three characters:

>>>>>CM:GREEN
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---
>>>>>CM:GREEN
  a   b   c   d   e   f   g   h   i   j   k   l   m   n   o   p   q   r   s   t   u   v   w   x   y   z
>>>>>CM:GREEN
  A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z
>>>>>CM:GREEN
  0   1   2   3   4   5   6   7   8   9   _                                                           
>>>>>CM:GREEN
  --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---

>>>>>CM:GREEN
The production CharacterClassEscape :: W evaluates by returning the set of all characters not
>>>>>CM:GREEN
included in the set returned by CharacterClassEscape :: w .

>>>>>CM:GREEN
15.10.2.13 CharacterClass
>>>>>CM:GREEN
=========================

>>>>>CM:GREEN
The production CharacterClass :: [ [lookahead ∉ {^}] ClassRanges ] evaluates by evaluating
>>>>>CM:GREEN
ClassRanges to obtain a CharSet and returning that CharSet and the Boolean false.

>>>>>CM:GREEN
The production CharacterClass :: [ ^ ClassRanges ] evaluates by evaluating ClassRanges to obtain a
>>>>>CM:GREEN
CharSet and returning that CharSet and the Boolean true.

>>>>>CM:GREEN
15.10.2.14 ClassRanges
>>>>>CM:GREEN
======================

>>>>>CM:GREEN
The production ClassRanges :: [empty] evaluates by returning the empty CharSet.

>>>>>CM:GREEN
The production ClassRanges :: NonemptyClassRanges evaluates by evaluating NonemptyClassRanges to
>>>>>CM:GREEN
obtain a CharSet and returning that CharSet.

>>>>>CM:GREEN
15.10.2.15 NonemptyClassRanges
>>>>>CM:GREEN
==============================

>>>>>CM:GREEN
The production NonemptyClassRanges :: ClassAtom evaluates by evaluating ClassAtom to obtain a
>>>>>CM:GREEN
CharSet and returning that CharSet.

>>>>>CM:GREEN
The production NonemptyClassRanges :: ClassAtom NonemptyClassRangesNoDash evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate ClassAtom to obtain a CharSet A.
>>>>>CM:GREEN
2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.
>>>>>CM:GREEN
3.  Return the union of CharSets A and B.

>>>>>CM:GREEN
The production NonemptyClassRanges :: ClassAtom - ClassAtom ClassRanges evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate the first ClassAtom to obtain a CharSet A.
>>>>>CM:GREEN
2.  Evaluate the second ClassAtom to obtain a CharSet B.
>>>>>CM:GREEN
3.  Evaluate ClassRanges to obtain a CharSet C.
>>>>>CM:GREEN
4.  Call CharacterRange(A, B) and let D be the resulting CharSet.
>>>>>CM:GREEN
5.  Return the union of CharSets D and C.

>>>>>CM:GREEN
The abstract operation CharacterRange takes two CharSet parameters A and B and performs the
>>>>>CM:GREEN
following:

>>>>>CM:GREEN
1.  If A does not contain exactly one character or B does not contain exactly one character then
>>>>>CM:GREEN
    throw a SyntaxError exception.
>>>>>CM:GREEN
2.  Let a be the one character in CharSet A.
>>>>>CM:GREEN
3.  Let b be the one character in CharSet B.
>>>>>CM:GREEN
4.  Let i be the code unit value of character a.
>>>>>CM:GREEN
5.  Let j be the code unit value of character b.
>>>>>CM:GREEN
6.  If i > j then throw a SyntaxError exception.
>>>>>CM:GREEN
7.  Return the set containing all characters numbered i through j, inclusive.

>>>>>CM:GREEN
15.10.2.16 NonemptyClassRangesNoDash
>>>>>CM:GREEN
====================================

>>>>>CM:GREEN
The production NonemptyClassRangesNoDash :: ClassAtom evaluates by evaluating ClassAtom to obtain a
>>>>>CM:GREEN
CharSet and returning that CharSet.

>>>>>CM:GREEN
The production NonemptyClassRangesNoDash :: ClassAtomNoDash NonemptyClassRangesNoDash evaluates as
>>>>>CM:GREEN
follows:

>>>>>CM:GREEN
1.  Evaluate ClassAtomNoDash to obtain a CharSet A.
>>>>>CM:GREEN
2.  Evaluate NonemptyClassRangesNoDash to obtain a CharSet B.
>>>>>CM:GREEN
3.  Return the union of CharSets A and B.

>>>>>CM:GREEN
The production NonemptyClassRangesNoDash :: ClassAtomNoDash - ClassAtom ClassRanges evaluates as
>>>>>CM:GREEN
follows:

>>>>>CM:GREEN
1.  Evaluate ClassAtomNoDash to obtain a CharSet A.
>>>>>CM:GREEN
2.  Evaluate ClassAtom to obtain a CharSet B.
>>>>>CM:GREEN
3.  Evaluate ClassRanges to obtain a CharSet C.
>>>>>CM:GREEN
4.  Call CharacterRange(A, B) and let D be the resulting CharSet.
>>>>>CM:GREEN
5.  Return the union of CharSets D and C.

>>>>>CM:GREEN
NOTE 1 ClassRanges can expand into single ClassAtoms and/or ranges of two ClassAtoms separated by
>>>>>CM:GREEN
dashes. In the latter case the ClassRanges includes all characters between the first ClassAtom and
>>>>>CM:GREEN
the second ClassAtom, inclusive; an error occurs if either ClassAtom does not represent a single
>>>>>CM:GREEN
character (for example, if one is \w) or if the first ClassAtom’s code unit value is greater than
>>>>>CM:GREEN
the second ClassAtom’s code unit value.

>>>>>CM:GREEN
NOTE 2 Even if the pattern ignores case, the case of the two ends of a range is significant in
>>>>>CM:GREEN
determining which characters belong to the range. Thus, for example, the pattern /[E-F]/i matches
>>>>>CM:GREEN
only the letters E, F, e, and f, while the pattern /[E-f]/i matches all upper and lower-case ASCII
>>>>>CM:GREEN
letters as well as the symbols [, \, ], ^, _, and `.

>>>>>CM:GREEN
NOTE 3 A - character can be treated literally or it can denote a range. It is treated literally if
>>>>>CM:GREEN
it is the first or last character of ClassRanges, the beginning or end limit of a range
>>>>>CM:GREEN
specification, or immediately follows a range specification.

>>>>>CM:GREEN
15.10.2.17 ClassAtom
>>>>>CM:GREEN
====================

>>>>>CM:GREEN
The production ClassAtom :: - evaluates by returning the CharSet containing the one character -.

>>>>>CM:GREEN
The production ClassAtom :: ClassAtomNoDash evaluates by evaluating ClassAtomNoDash to obtain a
>>>>>CM:GREEN
CharSet and returning that CharSet.

>>>>>CM:GREEN
15.10.2.18 ClassAtomNoDash
>>>>>CM:GREEN
==========================

>>>>>CM:GREEN
The production ClassAtomNoDash :: SourceCharacter but not one of \ or ] or - evaluates by returning
>>>>>CM:GREEN
a one-element CharSet containing the character represented by SourceCharacter.

>>>>>CM:GREEN
The production ClassAtomNoDash :: \ ClassEscape evaluates by evaluating ClassEscape to obtain a
>>>>>CM:GREEN
CharSet and returning that CharSet.

>>>>>CM:GREEN
15.10.2.19 ClassEscape
>>>>>CM:GREEN
======================

>>>>>CM:GREEN
The production ClassEscape :: DecimalEscape evaluates as follows:

>>>>>CM:GREEN
1.  Evaluate DecimalEscape to obtain an EscapeValue E.
>>>>>CM:GREEN
2.  If E is not a character then throw a SyntaxError exception.
>>>>>CM:GREEN
3.  Let ch be E’s character.
>>>>>CM:GREEN
4.  Return the one-element CharSet containing the character ch.

>>>>>CM:GREEN
The production ClassEscape :: b evaluates by returning the CharSet containing the one character <BS>
>>>>>CM:GREEN
(Unicode value 0008).

>>>>>CM:GREEN
The production ClassEscape :: CharacterEscape evaluates by evaluating CharacterEscape to obtain a
>>>>>CM:GREEN
character and returning a one-element CharSet containing that character.

>>>>>CM:GREEN
The production ClassEscape :: CharacterClassEscape evaluates by evaluating CharacterClassEscape to
>>>>>CM:GREEN
obtain a CharSet and returning that CharSet.

>>>>>CM:GREEN
NOTE A ClassAtom can use any of the escape sequences that are allowed in the rest of the regular
>>>>>CM:GREEN
expression except for \b, \B, and backreferences. Inside a CharacterClass, \b means the backspace
>>>>>CM:GREEN
character, while \B and backreferences raise errors. Using a backreference inside a ClassAtom causes
>>>>>CM:GREEN
an error.

>>>>>CM:GREEN
15.10.3 The RegExp Constructor Called as a Function
>>>>>CM:GREEN
===================================================

>>>>>CM:GREEN
15.10.3.1 RegExp(pattern, flags)
>>>>>CM:GREEN
================================

>>>>>CM:GREEN
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined, then
>>>>>CM:GREEN
return R unchanged. Otherwise call the standard built-in RegExp constructor (15.10.4.1) as if by the
>>>>>CM:GREEN
expression new         RegExp(pattern, flags) and return the object constructed by that constructor.

>>>>>CM:GREEN
15.10.4 The RegExp Constructor
>>>>>CM:GREEN
==============================

>>>>>CM:GREEN
When RegExp is called as part of a new expression, it is a constructor: it initialises the newly
>>>>>CM:GREEN
created object.

>>>>>CM:GREEN
15.10.4.1 new RegExp(pattern, flags)
>>>>>CM:GREEN
====================================

>>>>>CM:GREEN
If pattern is an object R whose [[Class]] internal property is "RegExp" and flags is undefined, then
>>>>>CM:GREEN
let P be the pattern used to construct R and let F be the flags used to construct R. If pattern is
>>>>>CM:GREEN
an object R whose [[Class]] internal property is "RegExp" and flags is not undefined, then throw a
>>>>>CM:GREEN
TypeError exception. Otherwise, let P be the empty String if pattern is undefined and
>>>>>CM:GREEN
ToString(pattern) otherwise, and let F be the empty String if flags is undefined and ToString(flags)
>>>>>CM:GREEN
otherwise.

>>>>>CM:GREEN
If the characters of P do not have the syntactic form Pattern, then throw a SyntaxError exception.
>>>>>CM:GREEN
Otherwise let the newly constructed object have a [[Match]] internal property obtained by evaluating
>>>>>CM:GREEN
(“compiling”) the characters of P as a Pattern as described in 15.10.2.

>>>>>CM:GREEN
If F contains any character other than "g", "i", or "m", or if it contains the same character more
>>>>>CM:GREEN
than once, then throw a SyntaxError exception.

>>>>>CM:GREEN
If a SyntaxError exception is not thrown, then:

>>>>>CM:GREEN
Let S be a String in the form of a Pattern equivalent to P, in which certain characters are escaped
>>>>>CM:GREEN
as described below. S may or may not be identical to P or pattern; however, the internal procedure
>>>>>CM:GREEN
that would result from evaluating S as a Pattern must behave identically to the internal procedure
>>>>>CM:GREEN
given by the constructed object’s [[Match]] internal property.

>>>>>CM:GREEN
The characters / occurring in the pattern shall be escaped in S as necessary to ensure that the
>>>>>CM:GREEN
String value formed by concatenating the Strings "/", S, "/", and F can be parsed (in an appropriate
>>>>>CM:GREEN
lexical context) as a RegularExpressionLiteral that behaves identically to the constructed regular
>>>>>CM:GREEN
expression. For example, if P is "/", then S could be "\/" or "\u002F", among other possibilities,
>>>>>CM:GREEN
but not "/", because /// followed by F would be parsed as a SingleLineComment rather than a
>>>>>CM:GREEN
RegularExpressionLiteral. If P is the empty String, this specification can be met by letting S be
>>>>>CM:GREEN
"(?:)".

>>>>>CM:GREEN
The following properties of the newly constructed object are data properties with the attributes
>>>>>CM:GREEN
that are specified in 15.10.7. The [[Value]] of each property is set as follows:

>>>>>CM:GREEN
The source property of the newly constructed object is set to S.

>>>>>CM:GREEN
The global property of the newly constructed object is set to a Boolean value that is true if F
>>>>>CM:GREEN
contains the character "g" and false otherwise.

>>>>>CM:GREEN
The ignoreCase property of the newly constructed object is set to a Boolean value that is true if F
>>>>>CM:GREEN
contains the character "i" and false otherwise.

>>>>>CM:GREEN
The multiline property of the newly constructed object is set to a Boolean value that is true if F
>>>>>CM:GREEN
contains the character "m" and false otherwise.

>>>>>CM:GREEN
The lastIndex property of the newly constructed object is set to 0.

>>>>>CM:GREEN
The [[Prototype]] internal property of the newly constructed object is set to the standard built-in
>>>>>CM:GREEN
RegExp prototype object as specified in 15.10.6.

>>>>>CM:GREEN
The [[Class]] internal property of the newly constructed object is set to "RegExp".

>>>>>CM:GREEN
NOTE If pattern is a StringLiteral, the usual escape sequence substitutions are performed before the
>>>>>CM:GREEN
String is processed by RegExp. If pattern must contain an escape sequence to be recognised by
>>>>>CM:GREEN
RegExp, any backslash \ characters must be escaped within the StringLiteral to prevent them being
>>>>>CM:GREEN
removed when the contents of the StringLiteral are formed.

>>>>>CM:GREEN
15.10.5 Properties of the RegExp Constructor
>>>>>CM:GREEN
============================================

>>>>>CM:GREEN
The value of the [[Prototype]] internal property of the RegExp constructor is the standard built-in
>>>>>CM:GREEN
Function prototype object (15.3.4).

>>>>>CM:GREEN
Besides the internal properties and the length property (whose value is 2), the RegExp constructor
>>>>>CM:GREEN
has the following properties:

>>>>>CM:GREEN
15.10.5.1 RegExp.prototype
>>>>>CM:GREEN
==========================

>>>>>CM:GREEN
The initial value of RegExp.prototype is the RegExp prototype object (15.10.6).

>>>>>CM:GREEN
This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false,
>>>>>CM:GREEN
[[Configurable]]: false }.

>>>>>CM:GREEN
15.10.6 Properties of the RegExp Prototype Object
>>>>>CM:GREEN
=================================================

>>>>>CM:GREEN
The value of the [[Prototype]] internal property of the RegExp prototype object is the standard
>>>>>CM:GREEN
built-in Object prototype object (15.2.4). The RegExp prototype object is itself a regular
>>>>>CM:GREEN
expression object; its [[Class]] is "RegExp". The initial values of the RegExp prototype object’s
>>>>>CM:GREEN
data properties (15.10.7) are set as if the object was created by the expression new       RegExp()
>>>>>CM:GREEN
where RegExp is that standard built-in constructor with that name.

>>>>>CM:GREEN
The RegExp prototype object does not have a valueOf property of its own; however, it inherits the
>>>>>CM:GREEN
valueOf property from the Object prototype object.

>>>>>CM:GREEN
In the following descriptions of functions that are properties of the RegExp prototype object, the
>>>>>CM:GREEN
phrase “this RegExp object” refers to the object that is the this value for the invocation of the
>>>>>CM:GREEN
function; a TypeError exception is thrown if the this value is not an object or an object for which
>>>>>CM:GREEN
the value of the [[Class]] internal property is not "RegExp".

>>>>>CM:GREEN
15.10.6.1 RegExp.prototype.constructor
>>>>>CM:GREEN
======================================

>>>>>CM:GREEN
The initial value of RegExp.prototype.constructor is the standard built-in RegExp constructor.

>>>>>CM:GREEN
15.10.6.2 RegExp.prototype.exec(string)
>>>>>CM:GREEN
=======================================

>>>>>CM:GREEN
Performs a regular expression match of string against the regular expression and returns an Array
>>>>>CM:GREEN
object containing the results of the match, or null if string did not match.

>>>>>CM:GREEN
The String ToString(string) is searched for an occurrence of the regular expression pattern as
>>>>>CM:GREEN
follows:

>>>>>CM:GREEN
1.  Let R be this RegExp object.
>>>>>CM:GREEN
2.  Let S be the value of ToString(string).
>>>>>CM:GREEN
3.  Let length be the length of S.
>>>>>CM:GREEN
4.  Let lastIndex be the result of calling the [[Get]] internal method of R with argument
>>>>>CM:GREEN
    "lastIndex".
>>>>>CM:GREEN
5.  Let i be the value of ToInteger(lastIndex).
>>>>>CM:GREEN
6.  Let global be the result of calling the [[Get]] internal method of R with argument "global".
>>>>>CM:GREEN
7.  If global is false, then let i = 0.
>>>>>CM:GREEN
8.  Let matchSucceeded be false.
>>>>>CM:GREEN
9.  Repeat, while matchSucceeded is false
>>>>>CM:GREEN
    1.  If i < 0 or i > length, then
>>>>>CM:GREEN
        1.  Call the [[Put]] internal method of R with arguments "lastIndex", 0, and true.
>>>>>CM:GREEN
        2.  Return null.

>>>>>CM:GREEN
    2.  Call the [[Match]] internal method of R with arguments S and i.
>>>>>CM:GREEN
    3.  If [[Match]] returned failure, then
>>>>>CM:GREEN
        1.  Let i = i+1.

>>>>>CM:GREEN
    4.  else
>>>>>CM:GREEN
        1.  Let r be the State result of the call to [[Match]].
>>>>>CM:GREEN
        2.  Set matchSucceeded to true.

>>>>>CM:GREEN
10. Let e be r’s endIndex value.
>>>>>CM:GREEN
11. If global is true,
>>>>>CM:GREEN
    1.  Call the [[Put]] internal method of R with arguments "lastIndex", e, and true.

>>>>>CM:GREEN
12. Let n be the length of r’s captures array. (This is the same value as 15.10.2.1’s
>>>>>CM:GREEN
    NCapturingParens.)
>>>>>CM:GREEN
13. Let A be a new array created as if by the expression new Array() where Array is the standard
>>>>>CM:GREEN
    built-in constructor with that name.
>>>>>CM:GREEN
14. Let matchIndex be i.
>>>>>CM:GREEN
15. Call the [[DefineOwnProperty]] internal method of A with arguments "index", Property Descriptor
>>>>>CM:GREEN
    {[[Value]]: matchIndex, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and
>>>>>CM:GREEN
    true.
>>>>>CM:GREEN
16. Call the [[DefineOwnProperty]] internal method of A with arguments "input", Property Descriptor
>>>>>CM:GREEN
    {[[Value]]: S, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and true.
>>>>>CM:GREEN
17. Call the [[DefineOwnProperty]] internal method of A with arguments "length", Property Descriptor
>>>>>CM:GREEN
    {[[Value]]: n + 1}, and true.
>>>>>CM:GREEN
18. Let matchedSubstr be the matched substring (i.e. the portion of S between offset i inclusive and
>>>>>CM:GREEN
    offset e exclusive).
>>>>>CM:GREEN
19. Call the [[DefineOwnProperty]] internal method of A with arguments "0", Property Descriptor
>>>>>CM:GREEN
    {[[Value]]: matchedSubstr, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]: true}, and
>>>>>CM:GREEN
    true.
>>>>>CM:GREEN
20. For each integer i such that i > 0 and i ≤ n
>>>>>CM:GREEN
    1.  Let captureI be ith element of r’s captures array.
>>>>>CM:GREEN
    2.  Call the [[DefineOwnProperty]] internal method of A with arguments ToString(i), Property
>>>>>CM:GREEN
        Descriptor {[[Value]]: captureI, [[Writable]: true, [[Enumerable]]: true, [[Configurable]]:
>>>>>CM:GREEN
        true}, and true.

>>>>>CM:GREEN
21. Return A.

>>>>>CM:GREEN
15.10.6.3 RegExp.prototype.test(string)
>>>>>CM:GREEN
=======================================

>>>>>CM:GREEN
The following steps are taken:

>>>>>CM:GREEN
1.  Let match be the result of evaluating the RegExp.prototype.exec (15.10.6.2) algorithm upon this
>>>>>CM:GREEN
    RegExp object using string as the argument.
>>>>>CM:GREEN
2.  If match is not null, then return true; else return false.

>>>>>CM:GREEN
15.10.6.4 RegExp.prototype.toString()
>>>>>CM:GREEN
=====================================

>>>>>CM:GREEN
Return the String value formed by concatenating the Strings "/", the String value of the source
>>>>>CM:GREEN
property of this RegExp object, and "/"; plus "g" if the global property is true, "i" if the
>>>>>CM:GREEN
ignoreCase property is true, and "m" if the multiline property is true.

>>>>>CM:GREEN
NOTE The returned String has the form of a RegularExpressionLiteral that evaluates to another RegExp
>>>>>CM:GREEN
object with the same behaviour as this object.

>>>>>CM:GREEN
15.10.7 Properties of RegExp Instances
>>>>>CM:GREEN
======================================

>>>>>CM:GREEN
RegExp instances inherit properties from the RegExp prototype object and their [[Class]] internal
>>>>>CM:GREEN
property value is "RegExp". RegExp instances also have a [[Match]] internal property and a length
>>>>>CM:GREEN
property.

>>>>>CM:GREEN
The value of the [[Match]] internal property is an implementation dependent representation of the
>>>>>CM:GREEN
Pattern of the RegExp object.

>>>>>CM:GREEN
RegExp instances also have the following properties.

>>>>>CM:GREEN
15.10.7.1 source
>>>>>CM:GREEN
================

>>>>>CM:GREEN
The value of the source property is a String in the form of a Pattern representing the current
>>>>>CM:GREEN
regular expression. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]:
>>>>>CM:GREEN
false, [[Configurable]]: false }.

>>>>>CM:GREEN
15.10.7.2 global
>>>>>CM:GREEN
================

>>>>>CM:GREEN
The value of the global property is a Boolean value indicating whether the flags contained the
>>>>>CM:GREEN
character “g”. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false,
>>>>>CM:GREEN
[[Configurable]]: false }.

>>>>>CM:GREEN
15.10.7.3 ignoreCase
>>>>>CM:GREEN
====================

>>>>>CM:GREEN
The value of the ignoreCase property is a Boolean value indicating whether the flags contained the
>>>>>CM:GREEN
character “i”. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false,
>>>>>CM:GREEN
[[Configurable]]: false }.

>>>>>CM:GREEN
15.10.7.4 multiline
>>>>>CM:GREEN
===================

>>>>>CM:GREEN
The value of the multiline property is a Boolean value indicating whether the flags contained the
>>>>>CM:GREEN
character “m”. This property shall have the attributes { [[Writable]]: false, [[Enumerable]]: false,
>>>>>CM:GREEN
[[Configurable]]: false }.

>>>>>CM:GREEN
15.10.7.5 lastIndex
>>>>>CM:GREEN
===================

>>>>>CM:GREEN
The value of the lastIndex property specifies the String position at which to start the next match.
>>>>>CM:GREEN
It is coerced to an integer when used (see 15.10.6.2). This property shall have the attributes
>>>>>CM:GREEN
{ [[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: false }.

>>>>>CM:GREEN
NOTE Unlike the other standard built-in properties of RegExp instances, lastIndex is writable.
