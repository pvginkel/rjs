15.1 The Global Object
======================

The unique global object is created before control enters any execution context.

Unless otherwise specified, the standard built-in properties of the global object have attributes
{[[Writable]]: true, [[Enumerable]]: false, [[Configurable]]: true}.

The global object does not have a [[Construct]] internal property; it is not possible to use the
global object as a constructor with the new operator.

The global object does not have a [[Call]] internal property; it is not possible to invoke the
global object as a function.

The values of the [[Prototype]] and [[Class]] internal properties of the global object are
implementation-dependent.

In addition to the properties defined in this specification the global object may have additional
host defined properties. This may include a property whose value is the global object itself; for
example, in the HTML document object model the window property of the global object is the global
object itself.

15.1.1 Value Properties of the Global Object
============================================

>>>>>CM:GREEN
15.1.1.1 NaN
>>>>>CM:GREEN
============

>>>>>CM:GREEN
The value of NaN is NaN (see 8.5). This property has the attributes { [[Writable]]: false,
>>>>>CM:GREEN
[[Enumerable]]: false, [[Configurable]]: false }.

>>>>>CM:GREEN
15.1.1.2 Infinity
>>>>>CM:GREEN
=================

>>>>>CM:GREEN
The value of Infinity is +∞ (see 8.5). This property has the attributes { [[Writable]]: false,
>>>>>CM:GREEN
[[Enumerable]]: false, [[Configurable]]: false }.

>>>>>CM:GREEN
15.1.1.3 undefined
>>>>>CM:GREEN
==================

>>>>>CM:GREEN
The value of undefined is undefined (see 8.1). This property has the attributes { [[Writable]]:
>>>>>CM:GREEN
false, [[Enumerable]]: false, [[Configurable]]: false }.

15.1.2 Function Properties of the Global Object
===============================================

>>>>>CM:GREEN
15.1.2.1 eval (x)
>>>>>CM:GREEN
=================

>>>>>CM:GREEN
When the eval function is called with one argument x, the following steps are taken:

>>>>>CM:GREEN
1.  If Type(x) is not String, return x.
>>>>>CM:GREEN
2.  Let prog be the ECMAScript code that is the result of parsing x as a Program. If the parse
>>>>>CM:GREEN
    fails, throw a SyntaxError exception (but see also clause 16).
>>>>>CM:YELLOW
3.  Let evalCtx be the result of establishing a new execution context (10.4.2) for the eval code
>>>>>CM:YELLOW
    prog.
>>>>>CM:GREEN
4.  Let result be the result of evaluating the program prog.
>>>>>CM:YELLOW
5.  Exit the running execution context evalCtx, restoring the previous execution context.
>>>>>CM:GREEN
6.  If result.type is normal and its completion value is a value V, then return the value V.
>>>>>CM:GREEN
7.  If result.type is normal and its completion value is empty, then return the value undefined.
>>>>>CM:GREEN
8.  Otherwise, result.type must be throw. Throw result.value as an exception.

15.1.2.1.1 Direct Call to Eval
==============================

A direct call to the eval function is one that is expressed as a CallExpression that meets the
following two conditions:

The Reference that is the result of evaluating the MemberExpression in the CallExpression has an
environment record as its base value and its reference name is "eval".

The result of calling the abstract operation GetValue with that Reference as the argument is the
standard built-in function defined in 15.1.2.1.

>>>>>CM:GREEN
15.1.2.2 parseInt (string , radix)
>>>>>CM:GREEN
==================================

>>>>>CM:GREEN
The parseInt function produces an integer value dictated by interpretation of the contents of the
>>>>>CM:GREEN
string argument according to the specified radix. Leading white space in string is ignored. If radix
>>>>>CM:GREEN
is undefined or 0, it is assumed to be 10 except when the number begins with the character pairs 0x
>>>>>CM:GREEN
or 0X, in which case a radix of 16 is assumed. If radix is 16, the number may also optionally begin
>>>>>CM:GREEN
with the character pairs 0x or 0X.

>>>>>CM:GREEN
When the parseInt function is called, the following steps are taken:

>>>>>CM:GREEN
1.  Let inputString be ToString(string).
>>>>>CM:GREEN
2.  Let S be a newly created substring of inputString consisting of the first character that is not
>>>>>CM:GREEN
    a StrWhiteSpaceChar and all characters following that character. (In other words, remove leading
>>>>>CM:GREEN
    white space.) If inputString does not contain any such characters, let S be the empty string.
>>>>>CM:GREEN
3.  Let sign be 1.
>>>>>CM:GREEN
4.  If S is not empty and the first character of S is a minus sign -, let sign be −1.
>>>>>CM:GREEN
5.  If S is not empty and the first character of S is a plus sign + or a minus sign -, then remove
>>>>>CM:GREEN
    the first character from S.
>>>>>CM:GREEN
6.  Let R = ToInt32(radix).
>>>>>CM:GREEN
7.  Let stripPrefix be true.
>>>>>CM:GREEN
8.  If R ≠ 0, then
>>>>>CM:GREEN
    1.  If R < 2 or R > 36, then return NaN.
>>>>>CM:GREEN
    2.  If R ≠ 16, let stripPrefix be false.

>>>>>CM:GREEN
9.  Else, R = 0
>>>>>CM:GREEN
    1.  Let R = 10.

>>>>>CM:GREEN
10. If stripPrefix is true, then
>>>>>CM:GREEN
    1.  If the length of S is at least 2 and the first two characters of S are either “0x” or “0X”,
>>>>>CM:GREEN
        then remove the first two characters from S and let R = 16.

>>>>>CM:GREEN
11. If S contains any character that is not a radix-R digit, then let Z be the substring of S
>>>>>CM:GREEN
    consisting of all characters before the first such character; otherwise, let Z be S.
>>>>>CM:GREEN
12. If Z is empty, return NaN.
>>>>>CM:GREEN
13. Let mathInt be the mathematical integer value that is represented by Z in radix-R notation,
>>>>>CM:GREEN
    using the letters A-Z and a-z for digits with values 10 through 35. (However, if R is 10 and Z
>>>>>CM:GREEN
    contains more than 20 significant digits, every significant digit after the 20th may be replaced
>>>>>CM:GREEN
    by a 0 digit, at the option of the implementation; and if R is not 2, 4, 8, 10, 16, or 32, then
>>>>>CM:GREEN
    mathInt may be an implementation-dependent approximation to the mathematical integer value that
>>>>>CM:GREEN
    is represented by Z in radix-R notation.)
>>>>>CM:GREEN
14. Let number be the Number value for mathInt.
>>>>>CM:GREEN
15. Return sign × number.

>>>>>CM:GREEN
NOTE parseInt may interpret only a leading portion of string as an integer value; it ignores any
>>>>>CM:GREEN
characters that cannot be interpreted as part of the notation of an integer, and no indication is
>>>>>CM:GREEN
given that any such characters were ignored.

>>>>>CM:GREEN
15.1.2.3 parseFloat (string)
>>>>>CM:GREEN
============================

>>>>>CM:GREEN
The parseFloat function produces a Number value dictated by interpretation of the contents of the
>>>>>CM:GREEN
string argument as a decimal literal.

>>>>>CM:GREEN
When the parseFloat function is called, the following steps are taken:

>>>>>CM:GREEN
1.  Let inputString be ToString(string).
>>>>>CM:GREEN
2.  Let trimmedString be a substring of inputString consisting of the leftmost character that is not
>>>>>CM:GREEN
    a StrWhiteSpaceChar and all characters to the right of that character. (In other words, remove
>>>>>CM:GREEN
    leading white space.) If inputString does not contain any such characters, let trimmedString be
>>>>>CM:GREEN
    the empty string.
>>>>>CM:GREEN
3.  If neither trimmedString nor any prefix of trimmedString satisfies the syntax of a
>>>>>CM:GREEN
    StrDecimalLiteral (see 9.3.1), return NaN.
>>>>>CM:GREEN
4.  Let numberString be the longest prefix of trimmedString, which might be trimmedString itself,
>>>>>CM:GREEN
    that satisfies the syntax of a StrDecimalLiteral.
>>>>>CM:GREEN
5.  Return the Number value for the MV of numberString.

>>>>>CM:GREEN
NOTE parseFloat may interpret only a leading portion of string as a Number value; it ignores any
>>>>>CM:GREEN
characters that cannot be interpreted as part of the notation of an decimal literal, and no
>>>>>CM:GREEN
indication is given that any such characters were ignored.

>>>>>CM:GREEN
15.1.2.4 isNaN (number)
>>>>>CM:GREEN
=======================

>>>>>CM:GREEN
Returns true if the argument coerces to NaN, and otherwise returns false.

>>>>>CM:GREEN
1.  If ToNumber(number) is NaN, return true.
>>>>>CM:GREEN
2.  Otherwise, return false.

>>>>>CM:GREEN
NOTE A reliable way for ECMAScript code to test if a value X is a NaN is an expression of the form X
>>>>>CM:GREEN
!== X. The result will be true if and only if X is a NaN.

>>>>>CM:GREEN
15.1.2.5 isFinite (number)
>>>>>CM:GREEN
==========================

>>>>>CM:GREEN
Returns false if the argument coerces to NaN, +∞, or −∞, and otherwise returns true.

>>>>>CM:GREEN
1.  If ToNumber(number) is NaN, +∞, or −∞, return false.
>>>>>CM:GREEN
2.  Otherwise, return true.

>>>>>CM:GREEN
15.1.3 URI Handling Function Properties
>>>>>CM:GREEN
=======================================

>>>>>CM:GREEN
Uniform Resource Identifiers, or URIs, are Strings that identify resources (e.g. web pages or files)
>>>>>CM:GREEN
and transport protocols by which to access them (e.g. HTTP or FTP) on the Internet. The ECMAScript
>>>>>CM:GREEN
language itself does not provide any support for using URIs except for functions that encode and
>>>>>CM:GREEN
decode URIs as described in 15.1.3.1, 15.1.3.2, 15.1.3.3 and 15.1.3.4.

>>>>>CM:GREEN
NOTE Many implementations of ECMAScript provide additional functions and methods that manipulate web
>>>>>CM:GREEN
pages; these functions are beyond the scope of this standard.

>>>>>CM:GREEN
A URI is composed of a sequence of components separated by component separators. The general form
>>>>>CM:GREEN
is:

>>>>>CM:GREEN
Scheme : First / Second ; Third ? Fourth

>>>>>CM:GREEN
where the italicised names represent components and “:”, “/”, “;” and “?” are reserved characters
>>>>>CM:GREEN
used as separators. The encodeURI and decodeURI functions are intended to work with complete URIs;
>>>>>CM:GREEN
they assume that any reserved characters in the URI are intended to have special meaning and so are
>>>>>CM:GREEN
not encoded. The encodeURIComponent and decodeURIComponent functions are intended to work with the
>>>>>CM:GREEN
individual component parts of a URI; they assume that any reserved characters represent text and so
>>>>>CM:GREEN
must be encoded so that they are not interpreted as reserved characters when the component is part
>>>>>CM:GREEN
of a complete URI.

>>>>>CM:GREEN
The following lexical grammar specifies the form of encoded URIs.

>>>>>CM:GREEN
Syntax
>>>>>CM:GREEN
------

>>>>>CM:GREEN
uri :::

>>>>>CM:GREEN
uriCharactersopt

>>>>>CM:GREEN
uriCharacters :::

>>>>>CM:GREEN
uriCharacter uriCharactersopt

>>>>>CM:GREEN
uriCharacter :::

>>>>>CM:GREEN
uriReserved

>>>>>CM:GREEN
uriUnescaped

>>>>>CM:GREEN
uriEscaped

>>>>>CM:GREEN
uriReserved ::: one of

>>>>>CM:GREEN
; / ? : @ & = + $ ,

>>>>>CM:GREEN
uriUnescaped :::

>>>>>CM:GREEN
uriAlpha

>>>>>CM:GREEN
DecimalDigit

>>>>>CM:GREEN
uriMark

>>>>>CM:GREEN
uriEscaped :::

>>>>>CM:GREEN
% HexDigit HexDigit

>>>>>CM:GREEN
uriAlpha ::: one of

>>>>>CM:GREEN
a b c d e f g h i j k l m n o p q r s t u v w x y z

>>>>>CM:GREEN
A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

>>>>>CM:GREEN
uriMark ::: one of

>>>>>CM:GREEN
- _ . ! ~ * ' ( )

>>>>>CM:GREEN
NOTE The above syntax is based upon RFC 2396 and does not reflect changes introduced by the more
>>>>>CM:GREEN
recent RFC 3986.

>>>>>CM:GREEN
When a character to be included in a URI is not listed above or is not intended to have the special
>>>>>CM:GREEN
meaning sometimes given to the reserved characters, that character must be encoded. The character is
>>>>>CM:GREEN
transformed into its UTF-8 encoding, with surrogate pairs first converted from UTF-16 to the
>>>>>CM:GREEN
corresponding code point value. (Note that for code units in the range [0,127] this results in a
>>>>>CM:GREEN
single octet with the same value.) The resulting sequence of octets is then transformed into a
>>>>>CM:GREEN
String with each octet represented by an escape sequence of the form “%xx”.

>>>>>CM:GREEN
The encoding and escaping process is described by the abstract operation Encode taking two String
>>>>>CM:GREEN
arguments string and unescapedSet.

>>>>>CM:GREEN
1.  Let strLen be the number of characters in string.
>>>>>CM:GREEN
2.  Let R be the empty String.
>>>>>CM:GREEN
3.  Let k be 0.
>>>>>CM:GREEN
4.  Repeat
>>>>>CM:GREEN
    1.  If k equals strLen, return R.
>>>>>CM:GREEN
    2.  Let C be the character at position k within string.
>>>>>CM:GREEN
    3.  If C is in unescapedSet, then
>>>>>CM:GREEN
        1.  Let S be a String containing only the character C.
>>>>>CM:GREEN
        2.  Let R be a new String value computed by concatenating the previous value of R and S.

>>>>>CM:GREEN
    4.  Else, C is not in unescapedSet
>>>>>CM:GREEN
        1.  If the code unit value of C is not less than 0xDC00 and not greater than 0xDFFF, throw a
>>>>>CM:GREEN
            URIError exception.
>>>>>CM:GREEN
        2.  If the code unit value of C is less than 0xD800 or greater than 0xDBFF, then
>>>>>CM:GREEN
            1.  Let V be the code unit value of C.

>>>>>CM:GREEN
        3.  Else,
>>>>>CM:GREEN
            1.  Increase k by 1.
>>>>>CM:GREEN
            2.  If k equals strLen, throw a URIError exception.
>>>>>CM:GREEN
            3.  Let kChar be the code unit value of the character at position k within string.
>>>>>CM:GREEN
            4.  If kChar is less than 0xDC00 or greater than 0xDFFF, throw a URIError exception.
>>>>>CM:GREEN
            5.  Let V be (((the code unit value of C) – 0xD800) × 0x400 + (kChar – 0xDC00) +
>>>>>CM:GREEN
                0x10000).

>>>>>CM:GREEN
        4.  Let Octets be the array of octets resulting by applying the UTF-8 transformation to V,
>>>>>CM:GREEN
            and let L be the array size.
>>>>>CM:GREEN
        5.  Let j be 0.
>>>>>CM:GREEN
        6.  Repeat, while j < L
>>>>>CM:GREEN
            1.  Let jOctet be the value at position j within Octets.
>>>>>CM:GREEN
            2.  Let S be a String containing three characters “%XY” where XY are two uppercase
>>>>>CM:GREEN
                hexadecimal digits encoding the value of jOctet.
>>>>>CM:GREEN
            3.  Let R be a new String value computed by concatenating the previous value of R and S.
>>>>>CM:GREEN
            4.  Increase j by 1.

>>>>>CM:GREEN
    5.  Increase k by 1.

>>>>>CM:GREEN
The unescaping and decoding process is described by the abstract operation Decode taking two String
>>>>>CM:GREEN
arguments string and reservedSet.

>>>>>CM:GREEN
1.  Let strLen be the number of characters in string.
>>>>>CM:GREEN
2.  Let R be the empty String.
>>>>>CM:GREEN
3.  Let k be 0.
>>>>>CM:GREEN
4.  Repeat
>>>>>CM:GREEN
    1.  If k equals strLen, return R.
>>>>>CM:GREEN
    2.  Let C be the character at position k within string.
>>>>>CM:GREEN
    3.  If C is not ‘%’, then
>>>>>CM:GREEN
        1.  Let S be the String containing only the character C.

>>>>>CM:GREEN
    4.  Else, C is ‘%’
>>>>>CM:GREEN
        1.  Let start be k.
>>>>>CM:GREEN
        2.  If k + 2 is greater than or equal to strLen, throw a URIError exception.
>>>>>CM:GREEN
        3.  If the characters at position (k+1) and (k + 2) within string do not represent
>>>>>CM:GREEN
            hexadecimal digits, throw a URIError exception.
>>>>>CM:GREEN
        4.  Let B be the 8-bit value represented by the two hexadecimal digits at position (k + 1)
>>>>>CM:GREEN
            and (k + 2).
>>>>>CM:GREEN
        5.  Increment k by 2.
>>>>>CM:GREEN
        6.  If the most significant bit in B is 0, then
>>>>>CM:GREEN
            1.  Let C be the character with code unit value B.
>>>>>CM:GREEN
            2.  If C is not in reservedSet, then
>>>>>CM:GREEN
                1.  Let S be the String containing only the character C.

>>>>>CM:GREEN
            3.  Else, C is in reservedSet
>>>>>CM:GREEN
                1.  Let S be the substring of string from position start to position k included.

>>>>>CM:GREEN
        7.  Else, the most significant bit in B is 1
>>>>>CM:GREEN
            1.  Let n be the smallest non-negative number such that (B << n) & 0x80 is equal to 0.
>>>>>CM:GREEN
            2.  If n equals 1 or n is greater than 4, throw a URIError exception.
>>>>>CM:GREEN
            3.  Let Octets be an array of 8-bit integers of size n.
>>>>>CM:GREEN
            4.  Put B into Octets at position 0.
>>>>>CM:GREEN
            5.  If k + (3 × (n – 1)) is greater than or equal to strLen, throw a URIError exception.
>>>>>CM:GREEN
            6.  Let j be 1.
>>>>>CM:GREEN
            7.  Repeat, while j < n
>>>>>CM:GREEN
                1.  Increment k by 1.
>>>>>CM:GREEN
                2.  If the character at position k is not ‘%’, throw a URIError exception.
>>>>>CM:GREEN
                3.  If the characters at position (k +1) and (k + 2) within string do not represent
>>>>>CM:GREEN
                    hexadecimal digits, throw a URIError exception.
>>>>>CM:GREEN
                4.  Let B be the 8-bit value represented by the two hexadecimal digits at position
>>>>>CM:GREEN
                    (k + 1) and (k + 2).
>>>>>CM:GREEN
                5.  If the two most significant bits in B are not 10, throw a URIError exception.
>>>>>CM:GREEN
                6.  Increment k by 2.
>>>>>CM:GREEN
                7.  Put B into Octets at position j.
>>>>>CM:GREEN
                8.  Increment j by 1.

>>>>>CM:GREEN
            8.  Let V be the value obtained by applying the UTF-8 transformation to Octets, that is,
>>>>>CM:GREEN
                from an array of octets into a 21-bit value. If Octets does not contain a valid
>>>>>CM:GREEN
                UTF-8 encoding of a Unicode code point throw an URIError exception.
>>>>>CM:GREEN
            9.  If V is less than 0x10000, then
>>>>>CM:GREEN
                1.  Let C be the character with code unit value V.
>>>>>CM:GREEN
                2.  If C is not in reservedSet, then
>>>>>CM:GREEN
                    1.  Let S be the String containing only the character C.

>>>>>CM:GREEN
                3.  Else, C is in reservedSet
>>>>>CM:GREEN
                    1.  Let S be the substring of string from position start to position k included.

>>>>>CM:GREEN
            10. Else, V is ≥ 0x10000
>>>>>CM:GREEN
                1.  Let L be (((V – 0x10000) & 0x3FF) + 0xDC00).
>>>>>CM:GREEN
                2.  Let H be ((((V – 0x10000) >> 10) & 0x3FF) + 0xD800).
>>>>>CM:GREEN
                3.  Let S be the String containing the two characters with code unit values H and L.

>>>>>CM:GREEN
    5.  Let R be a new String value computed by concatenating the previous value of R and S.
>>>>>CM:GREEN
    6.  Increase k by 1.

>>>>>CM:GREEN
NOTE This syntax of Uniform Resource Identifiers is based upon RFC 2396 and does not reflect the
>>>>>CM:GREEN
more recent RFC 3986 which replaces RFC 2396. A formal description and implementation of UTF-8 is
>>>>>CM:GREEN
given in RFC 3629.

>>>>>CM:GREEN
In UTF-8, characters are encoded using sequences of 1 to 6 octets. The only octet of a “sequence” of
>>>>>CM:GREEN
one has the higher-order bit set to 0, the remaining 7 bits being used to encode the character
>>>>>CM:GREEN
value. In a sequence of n octets, n>1, the initial octet has the n higher-order bits set to 1,
>>>>>CM:GREEN
followed by a bit set to 0. The remaining bits of that octet contain bits from the value of the
>>>>>CM:GREEN
character to be encoded. The following octets all have the higher-order bit set to 1 and the
>>>>>CM:GREEN
following bit set to 0, leaving 6 bits in each to contain bits from the character to be encoded. The
>>>>>CM:GREEN
possible UTF-8 encodings of ECMAScript characters are specified in Table 21.

>>>>>CM:GREEN
Table 21 — UTF-8 Encodings

>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| Code Unit Value  | Representation   | 1st Octet        | 2nd Octet        | 3rd Octet        | 4th Octet        |
>>>>>CM:GREEN
+==================+==================+==================+==================+==================+==================+
>>>>>CM:GREEN
| 0x0000 - 0x007F  | 00000000         | 0zzzzzzz         |                  |                  |                  |
>>>>>CM:GREEN
|                  | 0zzzzzzz         |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0x0080 - 0x07FF  | 00000yyy         | 110yyyyy         | 10zzzzzz         |                  |                  |
>>>>>CM:GREEN
|                  | yyzzzzzz         |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0x0800 - 0xD7FF  | xxxxyyyy         | 1110xxxx         | 10yyyyyy         | 10zzzzzz         |                  |
>>>>>CM:GREEN
|                  | yyzzzzzz         |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0xD800 - 0xDBFF  | 110110vv         | 11110uuu         | 10uuwwww         | 10xxyyyy         | 10zzzzzz         |
>>>>>CM:GREEN
|                  | vvwwwwxx         |                  |                  |                  |                  |
>>>>>CM:GREEN
| followed by      |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
|                  | followed by      |                  |                  |                  |                  |
>>>>>CM:GREEN
| 0xDC00 – 0xDFFF  |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
|                  | 110111yy         |                  |                  |                  |                  |
>>>>>CM:GREEN
|                  | yyzzzzzz         |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0xD800 - 0xDBFF  | causes URIError  |                  |                  |                  |                  |
>>>>>CM:GREEN
|                  |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
| not followed by  |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
|                  |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
| 0xDC00 – 0xDFFF  |                  |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0xDC00 – 0xDFFF  | causes URIError  |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+
>>>>>CM:GREEN
| 0xE000 - 0xFFFF  | xxxxyyyy         | 1110xxxx         | 10yyyyyy         | 10zzzzzz         |                  |
>>>>>CM:GREEN
|                  | yyzzzzzz         |                  |                  |                  |                  |
>>>>>CM:GREEN
+------------------+------------------+------------------+------------------+------------------+------------------+

>>>>>CM:GREEN
Where

>>>>>CM:GREEN
uuuuu = vvvv + 1

>>>>>CM:GREEN
to account for the addition of 0x10000 as in Surrogates, section 3.7, of the Unicode Standard.

>>>>>CM:GREEN
The range of code unit values 0xD800-0xDFFF is used to encode surrogate pairs; the above
>>>>>CM:GREEN
transformation combines a UTF-16 surrogate pair into a UTF-32 representation and encodes the
>>>>>CM:GREEN
resulting 21-bit value in UTF-8. Decoding reconstructs the surrogate pair.

>>>>>CM:GREEN
RFC 3629 prohibits the decoding of invalid UTF-8 octet sequences. For example, the invalid sequence
>>>>>CM:GREEN
C0 80 must not decode into the character U+0000. Implementations of the Decode algorithm are
>>>>>CM:GREEN
required to throw a URIError when encountering such invalid sequences.

>>>>>CM:GREEN
15.1.3.1 decodeURI (encodedURI)
>>>>>CM:GREEN
===============================

>>>>>CM:GREEN
The decodeURI function computes a new version of a URI in which each escape sequence and UTF-8
>>>>>CM:GREEN
encoding of the sort that might be introduced by the encodeURI function is replaced with the
>>>>>CM:GREEN
character that it represents. Escape sequences that could not have been introduced by encodeURI are
>>>>>CM:GREEN
not replaced.

>>>>>CM:GREEN
When the decodeURI function is called with one argument encodedURI, the following steps are taken:

>>>>>CM:GREEN
1.  Let uriString be ToString(encodedURI).
>>>>>CM:GREEN
2.  Let reservedURISet be a String containing one instance of each character valid in uriReserved
>>>>>CM:GREEN
    plus “#”.
>>>>>CM:GREEN
3.  Return the result of calling Decode(uriString, reservedURISet)

>>>>>CM:GREEN
NOTE The character “#” is not decoded from escape sequences even though it is not a reserved URI
>>>>>CM:GREEN
character.

>>>>>CM:GREEN
15.1.3.2 decodeURIComponent (encodedURIComponent)
>>>>>CM:GREEN
=================================================

>>>>>CM:GREEN
The decodeURIComponent function computes a new version of a URI in which each escape sequence and
>>>>>CM:GREEN
UTF-8 encoding of the sort that might be introduced by the encodeURIComponent function is replaced
>>>>>CM:GREEN
with the character that it represents.

>>>>>CM:GREEN
When the decodeURIComponent function is called with one argument encodedURIComponent, the following
>>>>>CM:GREEN
steps are taken:

>>>>>CM:GREEN
1.  Let componentString be ToString(encodedURIComponent).
>>>>>CM:GREEN
2.  Let reservedURIComponentSet be the empty String.
>>>>>CM:GREEN
3.  Return the result of calling Decode(componentString, reservedURIComponentSet)

>>>>>CM:GREEN
15.1.3.3 encodeURI (uri)
>>>>>CM:GREEN
========================

>>>>>CM:GREEN
The encodeURI function computes a new version of a URI in which each instance of certain characters
>>>>>CM:GREEN
is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding of the
>>>>>CM:GREEN
character.

>>>>>CM:GREEN
When the encodeURI function is called with one argument uri, the following steps are taken:

>>>>>CM:GREEN
1.  Let uriString be ToString(uri).
>>>>>CM:GREEN
2.  Let unescapedURISet be a String containing one instance of each character valid in uriReserved
>>>>>CM:GREEN
    and uriUnescaped plus “#”.
>>>>>CM:GREEN
3.  Return the result of calling Encode(uriString, unescapedURISet)

>>>>>CM:GREEN
NOTE The character “#” is not encoded to an escape sequence even though it is not a reserved or
>>>>>CM:GREEN
unescaped URI character.

>>>>>CM:GREEN
15.1.3.4 encodeURIComponent (uriComponent)
>>>>>CM:GREEN
==========================================

>>>>>CM:GREEN
The encodeURIComponent function computes a new version of a URI in which each instance of certain
>>>>>CM:GREEN
characters is replaced by one, two, three, or four escape sequences representing the UTF-8 encoding
>>>>>CM:GREEN
of the character.

>>>>>CM:GREEN
When the encodeURIComponent function is called with one argument uriComponent, the following steps
>>>>>CM:GREEN
are taken:

>>>>>CM:GREEN
1.  Let componentString be ToString(uriComponent).
>>>>>CM:GREEN
2.  Let unescapedURIComponentSet be a String containing one instance of each character valid in
>>>>>CM:GREEN
    uriUnescaped.
>>>>>CM:GREEN
3.  Return the result of calling Encode(componentString, unescapedURIComponentSet)

15.1.4 Constructor Properties of the Global Object
==================================================

15.1.4.1 Object ( . . . )
=========================

See 15.2.1 and 15.2.2.

15.1.4.2 Function ( . . . )
===========================

See 15.3.1 and 15.3.2.

15.1.4.3 Array ( . . . )
========================

See 15.4.1 and 15.4.2.

15.1.4.4 String ( . . . )
=========================

See 15.5.1 and 15.5.2.

15.1.4.5 Boolean ( . . . )
==========================

See 15.6.1 and 15.6.2.

15.1.4.6 Number ( . . . )
=========================

See 15.7.1 and 15.7.2.

15.1.4.7 Date ( . . . )
=======================

See 15.9.2.

15.1.4.8 RegExp ( . . . )
=========================

See 15.10.3 and 15.10.4.

15.1.4.9 Error ( . . . )
========================

See 15.11.1 and 15.11.2.

15.1.4.10 EvalError ( . . . )
=============================

See 15.11.6.1.

15.1.4.11 RangeError ( . . . )
==============================

See 15.11.6.2.

15.1.4.12 ReferenceError ( . . . )
==================================

See 15.11.6.3.

15.1.4.13 SyntaxError ( . . . )
===============================

See 15.11.6.4.

15.1.4.14 TypeError ( . . . )
=============================

See 15.11.6.5.

15.1.4.15 URIError ( . . . )
============================

See 15.11.6.6.

15.1.5 Other Properties of the Global Object
============================================

15.1.5.1 Math
=============

See 15.8.

15.1.5.2 JSON
=============

See 15.12.
