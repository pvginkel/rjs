15.12 The JSON Object
=====================

The JSON object is a single object that contains two functions, parse and stringify, that are used
to parse and construct JSON texts. The JSON Data Interchange Format is described in RFC 4627
<http://www.ietf.org/rfc/rfc4627.txt>. The JSON interchange format used in this specification is
exactly that described by RFC 4627 with two exceptions:

-   The top level JSONText production of the ECMAScript JSON grammar may consist of any JSONValue
    rather than being restricted to being a JSONObject or a JSONArray as specified by RFC 4627.

-   Conforming implementations of JSON.parse and JSON.stringify must support the exact interchange
    format described in this specification without any deletions or extensions to the format. This
    differs from RFC 4627 which permits a JSON parser to accept non-JSON forms and extensions.

The value of the [[Prototype]] internal property of the JSON object is the standard built-in Object
prototype object (15.2.4). The value of the [[Class]] internal property of the JSON object is
"JSON". The value of the [[Extensible]] internal property of the JSON object is set to true.

The JSON object does not have a [[Construct]] internal property; it is not possible to use the JSON
object as a constructor with the new operator.

The JSON object does not have a [[Call]] internal property; it is not possible to invoke the JSON
object as a function.

15.12.1 The JSON Grammar
========================

JSON.stringify produces a String that conforms to the following JSON grammar. JSON.parse accepts a
String that conforms to the JSON grammar.

15.12.1.1 The JSON Lexical Grammar
==================================

JSON is similar to ECMAScript source text in that it consists of a sequence of characters conforming
to the rules of SourceCharacter. The JSON Lexical Grammar defines the tokens that make up a JSON
text similar to the manner that the ECMAScript lexical grammar defines the tokens of an ECMAScript
source text. The JSON Lexical grammar only recognises the white space character specified by the
production JSONWhiteSpace. The JSON lexical grammar shares some productions with the ECMAScript
lexical grammar. All nonterminal symbols of the grammar that do not begin with the characters “JSON”
are defined by productions of the ECMAScript lexical grammar.

Syntax
------

JSONWhiteSpace ::

<TAB>  
<CR>  
<LF>  
<SP>

JSONString ::

" JSONStringCharactersopt "

JSONStringCharacters ::

JSONStringCharacter JSONStringCharactersopt

JSONStringCharacter ::

SourceCharacter but not one of " or \ or U+0000 through U+001F

\ JSONEscapeSequence

JSONEscapeSequence ::

JSONEscapeCharacter

UnicodeEscapeSequence

JSONEscapeCharacter :: one of

" / \ b f n r t

JSONNumber ::

-opt DecimalIntegerLiteral JSONFractionopt ExponentPartopt

JSONFraction ::

. DecimalDigits

JSONNullLiteral ::

NullLiteral

JSONBooleanLiteral ::

BooleanLiteral

15.12.1.2 The JSON Syntactic Grammar
====================================

The JSON Syntactic Grammar defines a valid JSON text in terms of tokens defined by the JSON lexical
grammar. The goal symbol of the grammar is JSONText.

Syntax
------

JSONText :

JSONValue

JSONValue :

JSONNullLiteral

JSONBooleanLiteral

JSONObject

JSONArray

JSONString

JSONNumber

JSONObject :

{ }

{ JSONMemberList }

JSONMember :

JSONString : JSONValue

JSONMemberList :

JSONMember

JSONMemberList , JSONMember

JSONArray :

[ ]

[ JSONElementList ]

JSONElementList :

JSONValue

JSONElementList , JSONValue

>>>>>CM:GREEN
15.12.2 parse ( text [ , reviver ] )
>>>>>CM:GREEN
====================================

>>>>>CM:GREEN
The parse function parses a JSON text (a JSON-formatted String) and produces an ECMAScript value.
>>>>>CM:GREEN
The JSON format is a restricted form of ECMAScript literal. JSON objects are realized as ECMAScript
>>>>>CM:GREEN
objects. JSON arrays are realized as ECMAScript arrays. JSON strings, numbers, booleans, and null
>>>>>CM:GREEN
are realized as ECMAScript Strings, Numbers, Booleans, and null. JSON uses a more limited set of
>>>>>CM:GREEN
white space characters than WhiteSpace and allows Unicode code points U+2028 and U+2029 to directly
>>>>>CM:GREEN
appear in JSONString literals without using an escape sequence. The process of parsing is similar to
>>>>>CM:GREEN
11.1.4 and 11.1.5 as constrained by the JSON grammar.

>>>>>CM:GREEN
The optional reviver parameter is a function that takes two parameters, (key and value). It can
>>>>>CM:GREEN
filter and transform the results. It is called with each of the key/value pairs produced by the
>>>>>CM:GREEN
parse, and its return value is used instead of the original value. If it returns what it received,
>>>>>CM:GREEN
the structure is not modified. If it returns undefined then the property is deleted from the result.

>>>>>CM:GREEN
1.  Let JText be ToString(text).
>>>>>CM:GREEN
2.  Parse JText using the grammars in 15.12.1. Throw a SyntaxError exception if JText did not
>>>>>CM:GREEN
    conform to the JSON grammar for the goal symbol JSONText.
>>>>>CM:GREEN
3.  Let unfiltered be the result of parsing and evaluating JText as if it was the source text of an
>>>>>CM:GREEN
    ECMAScript Program but using JSONString in place of StringLiteral. Note that since JText
>>>>>CM:GREEN
    conforms to the JSON grammar this result will be either a primitive value or an object that is
>>>>>CM:GREEN
    defined by either an ArrayLiteral or an ObjectLiteral.
>>>>>CM:YELLOW
4.  If IsCallable(reviver) is true, then
>>>>>CM:YELLOW
    1.  Let root be a new object created as if by the expression new Object(), where Object is the
>>>>>CM:YELLOW
        standard built-in constructor with that name.
>>>>>CM:YELLOW
    2.  Call the [[DefineOwnProperty]] internal method of root with the empty String, the
>>>>>CM:YELLOW
        PropertyDescriptor {[[Value]]: unfiltered, [[Writable]]: true, [[Enumerable]]: true,
>>>>>CM:YELLOW
        [[Configurable]]: true}, and false as arguments.
>>>>>CM:YELLOW
    3.  Return the result of calling the abstract operation Walk, passing root and the empty String.
>>>>>CM:YELLOW
        The abstract operation Walk is described below.

>>>>>CM:GREEN
5.  Else
>>>>>CM:GREEN
    1.  Return unfiltered.

>>>>>CM:YELLOW
The abstract operation Walk is a recursive abstract operation that takes two parameters: a holder
>>>>>CM:YELLOW
object and the String name of a property in that object. Walk uses the value of reviver that was
>>>>>CM:YELLOW
originally passed to the above parse function.

>>>>>CM:YELLOW
1.  Let val be the result of calling the [[Get]] internal method of holder with argument name.
>>>>>CM:YELLOW
2.  If val is an object, then
>>>>>CM:YELLOW
    1.  If the [[Class]] internal property of val is "Array"
>>>>>CM:YELLOW
        1.  Set I to 0.
>>>>>CM:YELLOW
        2.  Let len be the result of calling the [[Get]] internal method of val with argument
>>>>>CM:YELLOW
            "length".
>>>>>CM:YELLOW
        3.  Repeat while I < len,
>>>>>CM:YELLOW
            1.  Let newElement be the result of calling the abstract operation Walk, passing val and
>>>>>CM:YELLOW
                ToString(I).
>>>>>CM:YELLOW
            2.  If newElement is undefined, then
>>>>>CM:YELLOW
                1.  Call the [[Delete]] internal method of val with ToString(I) and false as
>>>>>CM:YELLOW
                    arguments.

>>>>>CM:YELLOW
            3.  Else
>>>>>CM:YELLOW
                1.  Call the [[DefineOwnProperty]] internal method of val with arguments
>>>>>CM:YELLOW
                    ToString(I), the Property Descriptor {[[Value]]: newElement, [[Writable]]: true,
>>>>>CM:YELLOW
                    [[Enumerable]]: true, [[Configurable]]: true}, and false.

>>>>>CM:YELLOW
            4.  Add 1 to I.

>>>>>CM:YELLOW
    2.  Else
>>>>>CM:YELLOW
        1.  Let keys be an internal List of String values consisting of the names of all the own
>>>>>CM:YELLOW
            properties of val whose [[Enumerable]] attribute is true. The ordering of the Strings
>>>>>CM:YELLOW
            should be the same as that used by the Object.keys standard built-in function.
>>>>>CM:YELLOW
        2.  For each String P in keys do,
>>>>>CM:YELLOW
            1.  Let newElement be the result of calling the abstract operation Walk, passing val and
>>>>>CM:YELLOW
                P.
>>>>>CM:YELLOW
            2.  If newElement is undefined, then
>>>>>CM:YELLOW
                1.  Call the [[Delete]] internal method of val with P and false as arguments.

>>>>>CM:YELLOW
            3.  Else
>>>>>CM:YELLOW
                1.  Call the [[DefineOwnProperty]] internal method of val with arguments P, the
>>>>>CM:YELLOW
                    Property Descriptor {[[Value]]: newElement, [[Writable]]: true, [[Enumerable]]:
>>>>>CM:YELLOW
                    true, [[Configurable]]: true}, and false.

>>>>>CM:YELLOW
3.  Return the result of calling the [[Call]] internal method of reviver passing holder as the this
>>>>>CM:YELLOW
    value and with an argument list consisting of name and val.

>>>>>CM:GREEN
It is not permitted for a conforming implementation of JSON.parse to extend the JSON grammars. If an
>>>>>CM:GREEN
implementation wishes to support a modified or extended JSON interchange format it must do so by
>>>>>CM:GREEN
defining a different parse function.

>>>>>CM:GREEN
NOTE In the case where there are duplicate name Strings within an object, lexically preceding values
>>>>>CM:GREEN
for the same key shall be overwritten.

>>>>>CM:GREEN
15.12.3 stringify ( value [ , replacer [ , space ] ] )
>>>>>CM:GREEN
======================================================

>>>>>CM:GREEN
The stringify function returns a String in JSON format representing an ECMAScript value. It can take
>>>>>CM:GREEN
three parameters. The first parameter is required. The value parameter is an ECMAScript value, which
>>>>>CM:GREEN
is usually an object or array, although it can also be a String, Boolean, Number or null. The
>>>>>CM:GREEN
optional replacer parameter is either a function that alters the way objects and arrays are
>>>>>CM:GREEN
stringified, or an array of Strings and Numbers that acts as a white list for selecting the object
>>>>>CM:GREEN
properties that will be stringified. The optional space parameter is a String or Number that allows
>>>>>CM:GREEN
the result to have white space injected into it to improve human readability.

>>>>>CM:GREEN
These are the steps in stringifying an object:

>>>>>CM:YELLOW
1.  Let stack be an empty List.
>>>>>CM:YELLOW
2.  Let indent be the empty String.
>>>>>CM:GREEN
3.  Let PropertyList and ReplacerFunction be undefined.
>>>>>CM:GREEN
4.  If Type(replacer) is Object, then
>>>>>CM:GREEN
    1.  If IsCallable(replacer) is true, then
>>>>>CM:GREEN
        1.  Let ReplacerFunction be replacer.

>>>>>CM:GREEN
    2.  Else if the [[Class]] internal property of replacer is "Array", then
>>>>>CM:GREEN
        1.  Let PropertyList be an empty internal List
>>>>>CM:GREEN
        2.  For each value v of a property of replacer that has an array index property name. The
>>>>>CM:GREEN
            properties are enumerated in the ascending array index order of their names.
>>>>>CM:GREEN
            1.  Let item be undefined.
>>>>>CM:GREEN
            2.  If Type(v) is String then let item be v.
>>>>>CM:GREEN
            3.  Else if Type(v) is Number then let item be ToString(v).
>>>>>CM:GREEN
            4.  Else if Type(v) is Object then,
>>>>>CM:GREEN
                1.  If the [[Class]] internal property of v is "String" or "Number" then let item be
>>>>>CM:GREEN
                    ToString(v).

>>>>>CM:GREEN
            5.  If item is not undefined and item is not currently an element of PropertyList then,
>>>>>CM:GREEN
                1.  Append item to the end of PropertyList.

>>>>>CM:YELLOW
5.  If Type(space) is Object then,
>>>>>CM:YELLOW
    1.  If the [[Class]] internal property of space is "Number" then,
>>>>>CM:YELLOW
        1.  Let space be ToNumber(space).

>>>>>CM:YELLOW
    2.  Else if the [[Class]] internal property of space is "String" then,
>>>>>CM:YELLOW
        1.  Let space be ToString(space).

>>>>>CM:YELLOW
6.  If Type(space) is Number
>>>>>CM:YELLOW
    1.  Let space be min(10, ToInteger(space)).
>>>>>CM:YELLOW
    2.  Set gap to a String containing space space characters. This will be the empty String if
>>>>>CM:YELLOW
        space is less than 1.

>>>>>CM:YELLOW
7.  Else if Type(space) is String
>>>>>CM:YELLOW
    1.  If the number of characters in space is 10 or less, set gap to space otherwise set gap to a
>>>>>CM:YELLOW
        String consisting of the first 10 characters of space.

>>>>>CM:YELLOW
8.  Else
>>>>>CM:YELLOW
    1.  Set gap to the empty String.

>>>>>CM:GREEN
9.  Let wrapper be a new object created as if by the expression new Object(), where Object is the
>>>>>CM:GREEN
    standard built-in constructor with that name.
>>>>>CM:GREEN
10. Call the [[DefineOwnProperty]] internal method of wrapper with arguments the empty String, the
>>>>>CM:GREEN
    Property Descriptor {[[Value]]: value, [[Writable]]: true, [[Enumerable]]: true,
>>>>>CM:GREEN
    [[Configurable]]: true}, and false.
>>>>>CM:GREEN
11. Return the result of calling the abstract operation Str with the empty String and wrapper.

>>>>>CM:GREEN
The abstract operation Str(key, holder) has access to ReplacerFunction from the invocation of the
>>>>>CM:GREEN
stringify method. Its algorithm is as follows:

>>>>>CM:GREEN
1.  Let value be the result of calling the [[Get]] internal method of holder with argument key.
>>>>>CM:GREEN
2.  If Type(value) is Object, then
>>>>>CM:GREEN
    1.  Let toJSON be the result of calling the [[Get]] internal method of value with argument
>>>>>CM:GREEN
        "toJSON".
>>>>>CM:GREEN
    2.  If IsCallable(toJSON) is true
>>>>>CM:GREEN
        1.  Let value be the result of calling the [[Call]] internal method of toJSON passing value
>>>>>CM:GREEN
            as the this value and with an argument list consisting of key.

>>>>>CM:GREEN
3.  If ReplacerFunction is not undefined, then
>>>>>CM:GREEN
    1.  Let value be the result of calling the [[Call]] internal method of ReplacerFunction passing
>>>>>CM:GREEN
        holder as the this value and with an argument list consisting of key and value.

>>>>>CM:GREEN
4.  If Type(value) is Object then,
>>>>>CM:GREEN
    1.  If the [[Class]] internal property of value is "Number" then,
>>>>>CM:GREEN
        1.  Let value be ToNumber(value).

>>>>>CM:GREEN
    2.  Else if the [[Class]] internal property of value is "String" then,
>>>>>CM:GREEN
        1.  Let value be ToString(value).

>>>>>CM:GREEN
    3.  Else if the [[Class]] internal property of value is "Boolean" then,
>>>>>CM:GREEN
        1.  Let value be the value of the [[PrimitiveValue]] internal property of value.

>>>>>CM:GREEN
5.  If value is null then return "null".
>>>>>CM:GREEN
6.  If value is true then return "true".
>>>>>CM:GREEN
7.  If value is false then return "false".
>>>>>CM:GREEN
8.  If Type(value) is String, then return the result of calling the abstract operation Quote with
>>>>>CM:GREEN
    argument value.
>>>>>CM:GREEN
9.  If Type(value) is Number
>>>>>CM:GREEN
    1.  If value is finite then return ToString(value).
>>>>>CM:GREEN
    2.  Else, return "null".

>>>>>CM:GREEN
10. If Type(value) is Object, and IsCallable(value) is false
>>>>>CM:GREEN
    1.  If the [[Class]] internal property of value is "Array" then
>>>>>CM:GREEN
        1.  Return the result of calling the abstract operation JA with argument value.

>>>>>CM:GREEN
    2.  Else, return the result of calling the abstract operation JO with argument value.

>>>>>CM:GREEN
11. Return undefined.

>>>>>CM:GREEN
The abstract operation Quote(value) wraps a String value in double quotes and escapes characters
>>>>>CM:GREEN
within it.

>>>>>CM:GREEN
1.  Let product be the double quote character.
>>>>>CM:GREEN
2.  For each character C in value
>>>>>CM:GREEN
    1.  If C is the double quote character or the backslash character
>>>>>CM:GREEN
        1.  Let product be the concatenation of product and the backslash character.
>>>>>CM:GREEN
        2.  Let product be the concatenation of product and C.

>>>>>CM:GREEN
    2.  Else if C is backspace, formfeed, newline, carriage return, or tab
>>>>>CM:GREEN
        1.  Let product be the concatenation of product and the backslash character.
>>>>>CM:GREEN
        2.  Let abbrev be the character corresponding to the value of C as follows:
>>>>>CM:GREEN
              ----------------- -----
>>>>>CM:GREEN
              backspace         “b”
>>>>>CM:GREEN
              formfeed          “f”
>>>>>CM:GREEN
              newline           “n”
>>>>>CM:GREEN
              carriage return   “r”
>>>>>CM:GREEN
              tab               “t”
>>>>>CM:GREEN
              ----------------- -----

>>>>>CM:GREEN
        3.  Let product be the concatenation of product and abbrev.

>>>>>CM:GREEN
    3.  Else if C is a control character having a code unit value less than the space character
>>>>>CM:GREEN
        1.  Let product be the concatenation of product and the backslash character.
>>>>>CM:GREEN
        2.  Let product be the concatenation of product and "u".
>>>>>CM:GREEN
        3.  Let hex be the result of converting the numeric code unit value of C to a String of four
>>>>>CM:GREEN
            hexadecimal digits.
>>>>>CM:GREEN
        4.  Let product be the concatenation of product and hex.

>>>>>CM:GREEN
    4.  Else
>>>>>CM:GREEN
        1.  Let product be the concatenation of product and C.

>>>>>CM:GREEN
3.  Let product be the concatenation of product and the double quote character.
>>>>>CM:GREEN
4.  Return product.

>>>>>CM:GREEN
The abstract operation JO(value) serializes an object. It has access to the stack, indent, gap,
>>>>>CM:GREEN
PropertyList, ReplacerFunction, and space of the invocation of the stringify method.

>>>>>CM:GREEN
1.  If stack contains value then throw a TypeError exception because the structure is cyclical.
>>>>>CM:GREEN
2.  Append value to stack.
>>>>>CM:YELLOW
3.  Let stepback be indent.
>>>>>CM:YELLOW
4.  Let indent be the concatenation of indent and gap.
>>>>>CM:YELLOW
5.  If PropertyList is not undefined, then
>>>>>CM:YELLOW
    1.  Let K be PropertyList.

>>>>>CM:GREEN
6.  Else
>>>>>CM:GREEN
    1.  Let K be an internal List of Strings consisting of the names of all the own properties of
>>>>>CM:GREEN
        value whose [[Enumerable]] attribute is true. The ordering of the Strings should be the same
>>>>>CM:GREEN
        as that used by the Object.keys standard built-in function.

>>>>>CM:GREEN
7.  Let partial be an empty List.
>>>>>CM:GREEN
8.  For each element P of K.
>>>>>CM:GREEN
    1.  Let strP be the result of calling the abstract operation Str with arguments P and value.
>>>>>CM:GREEN
    2.  If strP is not undefined
>>>>>CM:GREEN
        1.  Let member be the result of calling the abstract operation Quote with argument P.
>>>>>CM:GREEN
        2.  Let member be the concatenation of member and the colon character.
>>>>>CM:GREEN
        3.  If gap is not the empty String
>>>>>CM:GREEN
            1.  Let member be the concatenation of member and the space character.

>>>>>CM:GREEN
        4.  Let member be the concatenation of member and strP.
>>>>>CM:GREEN
        5.  Append member to partial.

>>>>>CM:GREEN
9.  If partial is empty, then
>>>>>CM:GREEN
    1.  Let final be "{}".

>>>>>CM:GREEN
10. Else
>>>>>CM:GREEN
    1.  If gap is the empty String
>>>>>CM:GREEN
        1.  Let properties be a String formed by concatenating all the element Strings of partial
>>>>>CM:GREEN
            with each adjacent pair of Strings separated with the comma character. A comma is not
>>>>>CM:GREEN
            inserted either before the first String or after the last String.
>>>>>CM:GREEN
        2.  Let final be the result of concatenating “{”, properties, and "}".

>>>>>CM:YELLOW
    2.  Else gap is not the empty String
>>>>>CM:YELLOW
        1.  Let separator be the result of concatenating the comma character, the line feed
>>>>>CM:YELLOW
            character, and indent.
>>>>>CM:YELLOW
        2.  Let properties be a String formed by concatenating all the element Strings of partial
>>>>>CM:YELLOW
            with each adjacent pair of Strings separated with separator. The separator String is not
>>>>>CM:YELLOW
            inserted either before the first String or after the last String.
>>>>>CM:YELLOW
        3.  Let final be the result of concatenating "{", the line feed character, indent,
>>>>>CM:YELLOW
            properties, the line feed character, stepback, and "}".

>>>>>CM:GREEN
11. Remove the last element of stack.
>>>>>CM:GREEN
12. Let indent be stepback.
>>>>>CM:GREEN
13. Return final.

>>>>>CM:GREEN
The abstract operation JA(value) serializes an array. It has access to the stack, indent, gap, and
>>>>>CM:GREEN
space of the invocation of the stringify method. The representation of arrays includes only the
>>>>>CM:GREEN
elements between zero and array.length – 1 inclusive. Named properties are excluded from the
>>>>>CM:GREEN
stringification. An array is stringified as an open left bracket, elements separated by comma, and a
>>>>>CM:GREEN
closing right bracket.

>>>>>CM:GREEN
1.  If stack contains value then throw a TypeError exception because the structure is cyclical.
>>>>>CM:GREEN
2.  Append value to stack.
>>>>>CM:YELLOW
3.  Let stepback be indent.
>>>>>CM:YELLOW
4.  Let indent be the concatenation of indent and gap.
>>>>>CM:GREEN
5.  Let partial be an empty List.
>>>>>CM:GREEN
6.  Let len be the result of calling the [[Get]] internal method of value with argument "length".
>>>>>CM:GREEN
7.  Let index be 0.
>>>>>CM:GREEN
8.  Repeat while index < len
>>>>>CM:GREEN
    1.  Let strP be the result of calling the abstract operation Str with arguments ToString(index)
>>>>>CM:GREEN
        and value.
>>>>>CM:GREEN
    2.  If strP is undefined
>>>>>CM:GREEN
        1.  Append "null" to partial.

>>>>>CM:GREEN
    3.  Else
>>>>>CM:GREEN
        1.  Append strP to partial.

>>>>>CM:GREEN
    4.  Increment index by 1.

>>>>>CM:GREEN
9.  If partial is empty ,then
>>>>>CM:GREEN
    1.  Let final be "[]".

>>>>>CM:GREEN
10. Else
>>>>>CM:GREEN
    1.  If gap is the empty String
>>>>>CM:GREEN
        1.  Let properties be a String formed by concatenating all the element Strings of partial
>>>>>CM:GREEN
            with each adjacent pair of Strings separated with the comma character. A comma is not
>>>>>CM:GREEN
            inserted either before the first String or after the last String.
>>>>>CM:GREEN
        2.  Let final be the result of concatenating “[”, properties, and "]".

>>>>>CM:GREEN
    2.  Else
>>>>>CM:GREEN
        1.  Let separator be the result of concatenating the comma character, the line feed
>>>>>CM:GREEN
            character, and indent.
>>>>>CM:GREEN
        2.  Let properties be a String formed by concatenating all the element Strings of partial
>>>>>CM:GREEN
            with each adjacent pair of Strings separated with separator. The separator String is not
>>>>>CM:GREEN
            inserted either before the first String or after the last String.
>>>>>CM:GREEN
        3.  Let final be the result of concatenating "[", the line feed character, indent,
>>>>>CM:GREEN
            properties, the line feed character, stepback, and "]".

>>>>>CM:GREEN
11. Remove the last element of stack.
>>>>>CM:GREEN
12. Let indent be stepback.
>>>>>CM:GREEN
13. Return final.

>>>>>CM:GREEN
NOTE 1 JSON structures are allowed to be nested to any depth, but they must be acyclic. If value is
>>>>>CM:GREEN
or contains a cyclic structure, then the stringify function must throw a TypeError exception. This
>>>>>CM:GREEN
is an example of a value that cannot be stringified:

>>>>>CM:GREEN
    a = [];

>>>>>CM:GREEN
    a[0] = a;

>>>>>CM:GREEN
    my_text = JSON.stringify(a); // This must throw an TypeError.

>>>>>CM:GREEN
NOTE 2 Symbolic primitive values are rendered as follows:

>>>>>CM:GREEN
-   The null value is rendered in JSON text as the String null.
>>>>>CM:GREEN
-   The undefined value is not rendered.
>>>>>CM:GREEN
-   The true value is rendered in JSON text as the String true.
>>>>>CM:GREEN
-   The false value is rendered in JSON text as the String false.

>>>>>CM:GREEN
NOTE 3 String values are wrapped in double quotes. The characters " and \ are escaped with \
>>>>>CM:GREEN
prefixes. Control characters are replaced with escape sequences \uHHHH, or with the shorter forms,
>>>>>CM:GREEN
\b (backspace), \f (formfeed), \n (newline), \r (carriage return), \t (tab).

>>>>>CM:GREEN
NOTE 4 Finite numbers are stringified as if by calling ToString(number). NaN and Infinity regardless
>>>>>CM:GREEN
of sign are represented as the String null.

>>>>>CM:GREEN
NOTE 5 Values that do not have a JSON representation (such as undefined and functions) do not
>>>>>CM:GREEN
produce a String. Instead they produce the undefined value. In arrays these values are represented
>>>>>CM:GREEN
as the String null. In objects an unrepresentable value causes the property to be excluded from
>>>>>CM:GREEN
stringification.

>>>>>CM:GREEN
NOTE 6 An object is rendered as an opening left brace followed by zero or more properties, separated
>>>>>CM:GREEN
with commas, closed with a right brace. A property is a quoted String representing the key or
>>>>>CM:GREEN
property name, a colon, and then the stringified property value. An array is rendered as an opening
>>>>>CM:GREEN
left bracket followed by zero or more values, separated with commas, closed with a right bracket.
